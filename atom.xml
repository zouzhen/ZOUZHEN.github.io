<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZOUZHEN_BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-17T01:25:30.547Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZOUZHEN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB学习记录</title>
    <link href="http://yoursite.com/2018/07/16/MongoDB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/16/MongoDB学习记录/</id>
    <published>2018-07-16T03:51:17.000Z</published>
    <updated>2018-07-17T01:25:30.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>转载自<a href="https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md" target="_blank" rel="noopener">https://github.com/zxhyJack/MyBlog/blob/master/mongodb/mongodb.md</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>文档<br>  是键值对的有序集合，这是MongDB的核心概念  </p></li><li><p>集合<br>  集合就是一组文档  </p><ul><li>动态模式<br>  集合是动态模式的，这意味着集合里面的文档可以是是各式各样的</li><li>命名<br>  集合使用名称进行命名  </li></ul></li><li><p>数据库<br>  由多个集合构成数据库，一个MongDB实例可以承载多个数据库，每个数据库拥有0个或多个集合  </p></li><li><p>基本操作<br>  在终端运行mongod命令，启动时，shell将自动连接MongDB数据库，需确保数据库已启动，可充分利用Javascript的标准库，还可定义和调用Javascript函数。</p><ul><li><p>创建数据库</p><pre><code>use database_name</code></pre><p>如果数据库存在，则进入指定数据库，否则，创建数据库<br>此时需要写入数据，数据库才能真正创建成功</p></li><li><p>查看所有数据库</p><pre><code>show databases | dbs</code></pre></li><li><p>创建集合</p><pre><code>db.createCollection(collection_name)</code></pre></li><li><p>删除数据库<br>先进入要删除的数据库，然后执行命令</p><pre><code>db.dropDatabase()</code></pre></li><li><p>删除集合</p><pre><code>db.collection_name.drop()</code></pre></li><li><p>增</p><pre><code>db.collection_name.insert(document)</code></pre><p>  exp:</p><pre><code>db.students.insert({name:&apos;James&apos;,age: 32,gender:&apos;man&apos;,career:&apos;player&apos;})</code></pre></li><li><p>查</p><pre><code>db.collection.find(&lt;query&gt;,&lt;projection&gt;)- query: 查询条件- projection: 投影操作</code></pre><p>  exp:</p><pre><code>db.students.find()</code></pre></li><li><p>改</p><pre><code>db.collection.updateOne(&lt;query&gt;,&lt;update&gt;) // 更新第一个符合条件的集合db.collection.updateMany(&lt;query&gt;,&lt;update&gt;)  // 更新所有符合条件的集合</code></pre><ul><li>query: 查询条件</li><li><p>update： 更新的内容</p><p>exp: </p><p>  db.students.update({name:’James’},{$set:{gender:’woman’}})</p></li></ul></li><li><p>删</p><pre><code>db.collection_name.deleteOne(&lt;query&gt;) // 删除第一个符合条件的集合db.collection_name.deleteMany(&lt;query&gt;) // 删除所有符合条件的集合</code></pre><p>  exp:</p><pre><code>db.students.deleteOne({name:&apos;James&apos;})</code></pre></li></ul></li></ul><h2 id="数据操作（重点）"><a href="#数据操作（重点）" class="headerlink" title="数据操作（重点）"></a>数据操作（重点）</h2><p>数据库的核心——CRUD，增加和删除较为简单，查询和修改较复杂</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><ul><li><p>$gt 大于</p></li><li><p>$lt 小于</p></li><li><p>$gte  大于等于</p></li><li><p>$lte  小于等于</p></li><li><p>$eq | (key: value)  等于</p></li><li><p>$ne 不等于</p></li></ul><p>先往数据库中添加一些数据</p><pre><code>db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;})db.students.insert({&apos;name&apos;:&apos;赵六&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:21,&apos;score&apos;: 60,&apos;address&apos;: &apos;东城区&apos;})db.students.insert({&apos;name&apos;:&apos;孙七&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 70,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;王八&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:23,&apos;score&apos;: 90,&apos;address&apos;: &apos;海淀区&apos;})db.students.insert({&apos;name&apos;:&apos;刘九&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:35,&apos;score&apos;: 56,&apos;address&apos;: &apos;朝阳区&apos;})db.students.insert({&apos;name&apos;:&apos;钱十&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:27,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;})</code></pre><p>exp:</p><ol><li><p>查询姓名是张三的学生信息</p><pre><code>db.students.find({name:’张三’}).pretty()</code></pre></li><li><p>查询性别是男的学生信息</p><pre><code>db.students.find({sex:’男’}).pretty()</code></pre></li><li><p>查询年龄大于19岁的学生</p><pre><code>db.students.find({age:{$gt:19}}).pretty()</code></pre></li><li><p>查询成绩大于等于60分的学生</p><pre><code>db.students.find({score:{$gte:60}}).pretty() </code></pre></li><li><p>查询姓名不是王五的信息</p><pre><code>db.students.find({name:{$ne:’王五’}}).pretty()</code></pre></li></ol><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><p><code>$and</code>   与</p></li><li><p><code>$or</code>   或</p></li><li><p><code>$not | $nor</code>  非</p></li></ul><p>exp:</p><ol><li><p>查询年龄在19 ~ 22岁的学生信息</p><pre><code>db.students.find({age:{$gte:19,$lte:22}}).pretty()</code></pre></li></ol><p>逻辑运算中与连接是最容易的，只需要利用<code>,</code>分割多个条件即可</p><ol start="2"><li><p>查询年龄小于20岁，或者成绩大于90分的学生信息</p><pre><code>db.students.find({$or:    [     {age:{$lt:20}},    {score:{$gt:90}}    ]}).pretty()</code></pre></li><li><p>查询年龄大于等于20岁，且成绩小于等于90分的学生信息</p><pre><code>db.students.find({$and:    [     {age:{$gte:20}},    {score:{$lte:90}}    ]}).pretty()</code></pre></li><li><p>查询年龄小于20岁的学生信息</p><pre><code>db.students.find({age:{$lt:20}}).pretty()db.students.find({age:{$not:{$gte:20}}}).pretty()</code></pre></li></ol><h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><p><code>$mod:[除数，余数]</code></p><p>exp: 查询年龄除以20余1的学生信息</p><pre><code>db.students.find({age:{$mod:[20,1]}}).pretty()</code></pre><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>$in: 在范围之中<br>$nin: 不在范围之中</p><p>exp:</p><ol><li><p>查询姓名是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$in:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pret ty()</code></pre></li><li><p>查询姓名不是”张三“、”李四、”王五“的学生</p><pre><code>db.students.find({name: {$nin:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]}}).pretty()</code></pre></li></ol><h4 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h4><ul><li><p>$all </p></li><li><p>$size </p></li><li><p>$slice </p></li><li><p>$elemMatch</p></li></ul><p>首先在数据库中新增一些数据</p><pre><code>db.students.insert({name:&apos;a&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;b&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;]})db.students.insert({name:&apos;c&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]})db.students.insert({name:&apos;d&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]})db.students.insert({name:&apos;e&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;政治&apos;]})</code></pre><p><code>$all</code>: 表示全都包括，用法：</p><pre><code>{$all:[内容1,内容2]}</code></pre><p>exp:</p><p>查询同时参加语文和数学的学生</p><pre><code>db.students.find({course:{$all:[&apos;语文&apos;,&apos;数学&apos;]}}).pretty()</code></pre><p>数组的操作，可以利用索引，使用<code>key.index</code>的方式来定义索引</p><p>查询数组中第二个内容是数学的学生(sh)</p><pre><code>db.students.find({&apos;course.1&apos;:&apos;数学&apos;}).pretty()</code></pre><p><code>$size</code>: 控制数组元素数量</p><p>exp:</p><p>查询只有两门课程的学生</p><pre><code>db.students.find({course:{$size: 2}}).pretty()</code></pre><p><code>$slice</code>: 控制查询结果的返回数量</p><p>exp:</p><p>查询年龄是19岁的学生，要求之显示两门参加的课程</p><pre><code>db.students.find({age:19},{course:{$slice:2}}).pretty()</code></pre><p>此时查询返回的是前两门课程，可以设置参数来取出想要的内容</p><pre><code>$slice:-2   //后两门$slice: [1,2]   // 第一个参数表示跳过的数据量，第二个参数表示返回的数据量</code></pre><h4 id="嵌套集合运算"><a href="#嵌套集合运算" class="headerlink" title="嵌套集合运算"></a>嵌套集合运算</h4><p>对象里面套对象</p><p>在数据库中新增数据</p><pre><code>db.students.insert({    name:&apos;A&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;],    parents:[        {name:&apos;A(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;A(mother)&apos;,age:50,job:&apos;职员&apos;}    ]})db.students.insert({    name:&apos;B&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;],    parents:[        {name:&apos;B(father)&apos;,age:50,job:&apos;处长&apos;},        {name:&apos;B(mother)&apos;,age:50,job:&apos;局长&apos;}    ]})db.students.insert({    name:&apos;C&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,    course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;],    parents:[        {name:&apos;C(father)&apos;,age:50,job:&apos;工人&apos;},        {name:&apos;C(mother)&apos;,age:50,job:&apos;局长&apos;}        ]})</code></pre><p>对于嵌套的集合中数据的判断只能通过<code>$elemMatch</code>完成</p><p>语法：<code>{ &lt;field&gt;: { $elemMatch: { &lt;query1&gt;, &lt;query2&gt;, ... } } }</code></p><p>exp:</p><p>查询父母中有人是局长的信息</p><pre><code>db.students.find({parents: {$elemMatch: {job: &apos;局长&apos;}}}).pretty()</code></pre><h4 id="判断某个字段是否存在"><a href="#判断某个字段是否存在" class="headerlink" title="判断某个字段是否存在"></a>判断某个字段是否存在</h4><p><code>{$exists:flag}</code>  flag为true表示存在，false表示不存在</p><p>exp:</p><ol><li><p>查询具有parents成员的学生</p><pre><code>db.students.find({parents:{$exists: true}}).pretty()</code></pre></li><li><p>查询不具有course成员的学生</p><pre><code>db.students.find({course: {$exists: false}}).pretty()</code></pre></li></ol><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>sort({ field: value })</code> value是1表示升序，-1表示降序</p><p>exp:</p><p>学生信息按照分数降序排列</p><pre><code>db.students.find().sort({score:-1}).pretty()</code></pre><h4 id="分页显示"><a href="#分页显示" class="headerlink" title="分页显示"></a>分页显示</h4><p><code>skip(n)</code>: 跳过n条数据</p><p><code>limit(n)</code>: 返回n条数据</p><p>exp:</p><ol><li><p>分页显示，第一页，每页显示5条数据</p><pre><code>db.students.find({}).skip(0).limit(5).pretty()</code></pre></li><li><p>分页显示，第二页，每页显示5条数据</p><pre><code>db.students.find({}).skip(5).limit(5).pretty()</code></pre></li></ol><h3 id="数据修改-更新"><a href="#数据修改-更新" class="headerlink" title="数据修改 | 更新"></a>数据修改 | 更新</h3><p><code>updateOne()</code>     修改匹配的第一条数据</p><p><code>updateMany()</code>    修改所有匹配的数据</p><p>格式：<code>updateOne(&lt;filter&gt;,&lt;update&gt;)</code></p><h4 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h4><p><code>$inc</code>: 操作数字字段的数据内容</p><p>语法: <code>{&quot;$inc&quot; : {成员 : 内容}}</code></p><p>exp: </p><p>将所有年龄为19岁的学生成绩一律减少30分，年龄增加1</p><pre><code>db.students.updateMany({age:19},{$inc:{score:-30,age:1}})</code></pre><p><code>$set</code>: 更新内容</p><p>语法：<code>{$set: :{属性: 新内容}}</code></p><p>exp: </p><p>将20岁学生的成绩修改为89</p><pre><code>db.students.updateMany({age: 20},{$set: {score: 89}})</code></pre><p><code>$unset</code>: 删除某个属性及其内容</p><p>语法：<code>{$unset: {属性: 1}}</code></p><p>exp:</p><p>删除张三的年龄和成绩信息</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$unset: {age: 1,score: 1}})</code></pre><p><code>$push</code>: 向数组中添加数据</p><p>语法：<code>{$push: {属性: value}}</code></p><p>exp:</p><p>在李四的课程中添加语文</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$push: {course: &apos;语文&apos;}})</code></pre><p>如果需要向数组中添加多个数据，则需要用到<code>$each</code></p><p>exp: </p><p>在李四的课程中添加数学、英语</p><pre><code>db.students.updateOne(    {name:&apos;李四&apos;},    {$push:        {            course:{$each: [&apos;数学&apos;,&apos;英语&apos;]}        }    })</code></pre><p><code>$addToSet</code>: 向数组里面添加一个新的数据</p><p>与<code>$push</code>的区别，<code>$push</code>添加的数据可能是重复的，<code>$addToSet</code>只有这个数据不存在时才会添加（去重）</p><p>语法：<code>{$addToSet: {属性：value}}</code></p><p>exp:</p><p>王五新增一门舞蹈课程</p><pre><code>db.students.updateOne(    {name:&apos;王五&apos;},    {$addToSet: {course:&apos;舞蹈&apos;}})</code></pre><p><code>$pop</code>: 删除数组内的数据</p><p>语法：<code>{$pop: {field: value}}</code>,value为-1表示删除第一个，value为1表示删除最后一个</p><p>exp:</p><p>删除王五的第一个课程</p><pre><code>db.students.updateOne({name:&apos;王五&apos;},{$pop:{course:-1}})</code></pre><p>只是删除属性的内容，属性还在</p><p><code>$pull</code>: 从数组中删除一个指定内容的数据</p><p>语法：<code>{$pull: {field：value}}</code> 进行数据比对，如果是该数据则删除</p><p>exp:</p><p>删除李四的语文课程</p><pre><code>db.students.updateOne({name: &apos;李四&apos;},{$pull:{course:&apos;语文&apos;}})</code></pre><p><code>$pullAll</code>: 一次删除多个数据</p><p>语法：<code>{$pullAll:{field:[value1,value2...]}}</code></p><p>exp:</p><p>删除a的语文数学英语课程</p><pre><code>db.students.updateOne({name:&apos;a&apos;},{$pullAll:{course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}})</code></pre><p><code>$rename</code>: 属性重命名</p><p>语法： <code>{$rename: {旧属性名：新属性名}}</code></p><p>exp:</p><p>把张三的name属性名改为姓名</p><pre><code>db.students.updateOne({name:&apos;张三&apos;},{$rename:{name:&apos;姓名&apos;}})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h1&gt;&lt;p&gt;转载自&lt;a href=&quot;https://github.com/zxhyJack/MyBlog/blo
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>facenet详解</title>
    <link href="http://yoursite.com/2018/07/14/facenet%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/07/14/facenet详解/</id>
    <published>2018-07-14T08:35:26.000Z</published>
    <updated>2018-07-18T12:35:45.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="facenet算法初测"><a href="#facenet算法初测" class="headerlink" title="facenet算法初测"></a>facenet算法初测</h2><ul><li><p><a href="https://github.com/davidsandberg/facenet" target="_blank" rel="noopener">facenet代码地址</a></p></li><li><p><a href="https://www.cnblogs.com/bakari/archive/2012/08/27/2658956.html" target="_blank" rel="noopener">数据对齐详解</a></p></li><li><p><a href="https://drive.google.com/file/d/1R77HmFADxe87GmoLwzfgMu_HY0IhcyBz/view" target="_blank" rel="noopener">已训练模型下载(基于CASIA-WebFace)</a></p></li><li><p><a href="https://blog.csdn.net/u013044310/article/details/79556099" target="_blank" rel="noopener">主要参考博客</a></p></li></ul><hr><h3 id="算法代码结构"><a href="#算法代码结构" class="headerlink" title="算法代码结构"></a>算法代码结构</h3><p>结构如图：<br><img src="/2018/07/14/facenet详解/算法结构.png" alt="代码结构">  </p><ul><li><p>|—— contribute (包含对人脸进行处理的函数)  </p></li><li><p>|—— data (原算法进行训练或测试时使用的图片数据)  </p></li><li><p>|—— lfw (储存的lfw数据集)  </p></li><li><p>|—— lfw_mtcnnpy_160 (储存的经过对齐后的图片数据)  </p></li><li><p>|—— models (存储训练模型)  </p></li><li><p>|—— src (核心功能相关的代码)  </p></li><li><p>|—— test (算法、模型测试相关的代码)  </p></li><li><p>|—— tmp (暂不清楚)  </p></li><li><p>|—— 其他  </p></li></ul><hr><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><ul><li><p>预训练模型测试：  </p><pre><code>python src/validate_on_lfw.py lfw_mtcnnpy_160 models\20180408-102900  </code></pre></li></ul><p><img src="/2018/07/14/facenet详解/算法测试.png" alt="算法测试">  </p><p>然而测试结果并不是特别好，可能是仅用CPU的缘故  </p><ul><li><p>相似人脸对比结果：  </p><pre><code>python src\compare.py models\20180408-102900 data\images\Anthony_Hopkins_0001.jpg data\images\Anthony_Hopkins_0002.jpg  </code></pre></li></ul><p><img src="/2018/07/14/facenet详解/相似人脸对比结果.png" alt="相似人脸对比结果">  </p><ul><li><p>不相似人脸对比结果：  </p><pre><code>python src\compare.py models\20180408-102900 data\images\Anthony_Hopkins_0001.jpg lfw_mtcnnpy_160\Aaron_Eckhart\Aaron_Eckhart_0001.png</code></pre></li></ul><p><img src="/2018/07/14/facenet详解/不相似人脸对比结果.png" alt="不相似人脸对比结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;facenet算法初测&quot;&gt;&lt;a href=&quot;#facenet算法初测&quot; class=&quot;headerlink&quot; title=&quot;facenet算法初测&quot;&gt;&lt;/a&gt;facenet算法初测&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="facenet" scheme="http://yoursite.com/tags/facenet/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript使用记录</title>
    <link href="http://yoursite.com/2018/07/12/JavaScript%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/12/JavaScript使用记录/</id>
    <published>2018-07-12T06:20:08.000Z</published>
    <updated>2018-07-14T12:42:53.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在JavaScript的世界中，所有代码都是单线程执行的。</p><p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：  </p><pre><code>function callback() {    console.log(&apos;Done&apos;);}console.log(&apos;before setTimeout()&apos;);setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log(&apos;after setTimeout()&apos;);</code></pre><p>观察上述代码执行，在Chrome的控制台输出可以看到：</p><pre><code>before setTimeout()after setTimeout()(等待1秒后)Done  </code></pre><p>可见，异步操作会在将来的某个时间点触发一个函数调用。</p><p>AJAX就是典型的异步操作。以之前的代码为例：</p><pre><code>request.onreadystatechange = function () {    if (request.readyState === 4) {        if (request.status === 200) {            return success(request.responseText);        } else {            return fail(request.status);        }    }}  </code></pre><p>把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p><p>有没有更好的写法？比如写成这样：</p><pre><code>var ajax = ajaxGet(&apos;http://...&apos;);ajax.ifSuccess(success)    .ifFail(fail);</code></pre><p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。</p><p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。<br>Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。  </p><p>我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：</p><pre><code>function test(resolve, reject) {    var timeOut = Math.random() * 2;    log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);    setTimeout(function () {        if (timeOut &lt; 1) {            log(&apos;call resolve()...&apos;);            resolve(&apos;200 OK&apos;);        }        else {            log(&apos;call reject()...&apos;);            reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);        }    }, timeOut * 1000);}</code></pre><p>这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve(‘200 OK’)，如果执行失败，我们将调用reject(‘timeout in ‘ + timeOut + ‘ seconds.’)。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。</p><p>有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：</p><pre><code>var p1 = new Promise(test);var p2 = p1.then(function (result) {    console.log(&apos;成功：&apos; + result);});var p3 = p2.catch(function (reason) {    console.log(&apos;失败：&apos; + reason);});</code></pre><p>变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：</p><p>// 如果成功，执行这个函数：  </p><pre><code>p1.then(function (result) {    console.log(&apos;成功：&apos; + result);});</code></pre><p>当test函数执行失败时，我们告诉Promise对象：</p><pre><code>p2.catch(function (reason) {    console.log(&apos;失败：&apos; + reason);});</code></pre><p>Promise对象可以串联起来，所以上述代码可以简化为：</p><pre><code>new Promise(test).then(function (result) {    console.log(&apos;成功：&apos; + result);}).catch(function (reason) {    console.log(&apos;失败：&apos; + reason);}); </code></pre><p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：<br><img src="/2018/07/12/JavaScript使用记录/l.png" alt="图片">  </p><p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p><p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p><pre><code>job1.then(job2).then(job3).catch(handleError);  </code></pre><p>其中，job1、job2和job3都是Promise对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h3&gt;&lt;p&gt;在JavaScript的世界中，所有代码都是单线程执行的。&lt;/p&gt;
&lt;p&gt;由于这个“缺陷”，导致Ja
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Git使用</title>
    <link href="http://yoursite.com/2018/07/12/Git%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/12/Git使用/</id>
    <published>2018-07-12T03:27:13.000Z</published>
    <updated>2018-07-12T03:32:08.825Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://blog.csdn.net/zwhfyy/article/details/8625228，如有侵权，请联系删除" target="_blank" rel="noopener">https://blog.csdn.net/zwhfyy/article/details/8625228，如有侵权，请联系删除</a></p><h1 id="出错信息"><a href="#出错信息" class="headerlink" title="出错信息"></a>出错信息</h1><p>Your local changes to the following files would be overwritten by merge<br>error: Your local changes to the following files would be overwritten by merge:<br>        123.txt<br>Please, commit your changes or stash them before you can merge.</p><p>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:  </p><pre><code>git stashgit pullgit stash pop  </code></pre><p>然后可以使用git diff -w +文件名 来确认代码自动合并的情况.</p><p>反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:  </p><pre><code>git reset --hardgit pull其中git reset是针对版本,如果想针对文件回退本地修改,使用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自&lt;a href=&quot;https://blog.csdn.net/zwhfyy/article/details/8625228，如有侵权，请联系删除&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zwhfyy/
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别算法发展情况</title>
    <link href="http://yoursite.com/2018/07/10/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E5%8F%91%E5%B1%95%E6%83%85%E5%86%B5/"/>
    <id>http://yoursite.com/2018/07/10/人脸识别算法发展情况/</id>
    <published>2018-07-10T09:09:03.000Z</published>
    <updated>2018-07-14T12:42:53.222Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://zhuanlan.zhihu.com/p/36416906，如有侵权，请联系删除。" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36416906，如有侵权，请联系删除。</a></p><h1 id="人脸识别概述"><a href="#人脸识别概述" class="headerlink" title="人脸识别概述"></a>人脸识别概述</h1><p>人脸识别的目标是确定一张人脸图像的身份，即这个人是谁，这是机器学习和模式识别中的分类问题。它主要应用在身份识别和身份验证中。</p><h2 id="人脸识别系统的组成"><a href="#人脸识别系统的组成" class="headerlink" title="人脸识别系统的组成"></a>人脸识别系统的组成</h2><pre><code>人脸检测（Face Detection）人脸对齐（Face Alignment）人脸特征表征（Feature Representation）</code></pre><ul><li><p>人脸检测</p><p>  人脸检测用于确定人脸在图像中的大小和位置，即解决“人脸在哪里”的问题，把真正的人脸区域从图像中裁剪出来，便于后续的人脸特征分析和识别。  </p></li><li><p>人脸对齐</p><p>  同一个人在不同的图像序列中可能呈现出不同的姿态和表情，这种情况是不利于人脸识别的。所以有必要将人脸图像都变换到一个统一的角度和姿态，这就是人脸对齐。它的原理是找到人脸的若干个关键点（基准点，如眼角，鼻尖，嘴角等），然后利用这些对应的关键点通过相似变换（Similarity Transform，旋转、缩放和平移）将人脸尽可能变换到标准人脸。  </p></li><li><p>人脸特征表征</p><p>  第三个模块是本文重点要讲的人脸识别算法，它接受的输入是标准化的人脸图像，通过特征建模得到向量化的人脸特征，最后通过分类器判别得到识别的结果。这里的关键是怎样得到对不同人脸有区分度的特征，通常我们在识别一个人时会看它的眉形、脸轮廓、鼻子形状、眼睛的类型等，人脸识别算法引擎要通过练习（训练）得到类似这样的有区分度的特征。本系列文章主要围绕人脸识别中的人脸特征表征进行展开，人脸检测和人脸对齐方法会在其它专题系列文章中进行介绍。</p></li></ul><h2 id="人脸识别算法的三个阶段"><a href="#人脸识别算法的三个阶段" class="headerlink" title="人脸识别算法的三个阶段"></a>人脸识别算法的三个阶段</h2><p>人脸识别算法经历了早期算法，人工特征+分类器，深度学习3个阶段。目前深度学习算法是主流，极大的提高了人脸识别的精度。  </p><ul><li><p>早期算法  </p><p>  早期的算法有基于几何特征的算法，基于模板匹配的算法，子空间算法等多种类型。子空间算法将人脸图像当成一个高维的向量，将向量投影到低维空间中，投影之后得到的低维向量达到对不同的人具有良好的区分度。</p><p>  子空间算法的典型代表是PCA（主成分分析，也称为特征脸EigenFace）[1]和LDA（线性判别分析，FisherFace）[2]。PCA的核心思想是在进行投影之后尽量多的保留原始数据的主要信息，降低数据的冗余信息，以利于后续的识别。LDA的核心思想是最大化类间差异，最小化类内差异，即保证同一个人的不同人脸图像在投影之后聚集在一起，不同人的人脸图像在投影之后被用一个大的间距分开。PCA和LDA最后都归结于求解矩阵的特征值和特征向量，这有成熟的数值算法可以实现。</p><p>  PCA和LDA都是线性降维技术，但人脸在高维空间中的分布显然是非线性的，因此可以使用非线性降维算法，典型的代表是流形学习[3]和核（kernel）技术。流形学习假设向量点在高维空间中的分布具有某些几何形状，然后在保持这些几何形状约束的前提下将向量投影到低维空间中，这种投影是通过非线性变换完成的。  </p></li><li><p>人工特征 + 分类器  </p><p>  第二阶段的人脸识别算法普遍采用了人工特征 + 分类器的思路。分类器有成熟的方案，如神经网络，支持向量机[7]，贝叶斯[8]等。这里的关键是人工特征的设计，它要能有效的区分不同的人。</p><p>  描述图像的很多特征都先后被用于人脸识别问题，包括HOG、SIFT、Gabor、LBP等。它们中的典型代表是LBP（局部二值模式）特征[9]，这种特征简单却有效。LBP特征计算起来非常简单，部分解决了光照敏感问题，但还是存在姿态和表情的问题。</p><p>  联合贝叶斯是对贝叶斯人脸的改进方法[8]，选用LBP和LE作为基础特征，将人脸图像的差异表示为相同人因姿态、表情等导致的差异以及不同人间的差异两个因素，用潜在变量组成的协方差，建立两张人脸的关联。文章的创新点在于将两个人脸表示进行联合建模，在人脸联合建模的时候，又使用了人脸的先验知识，将两张人脸的建模问题变为单张人脸图片的统计计算，更好的验证人脸的相关性，该方法在LFW上取得了92.4%的准确率。</p><p>  人工特征的巅峰之作是出自CVPR 2013年MSRA的”Blessing of Dimisionality: High Dimensional Feature and Its Efficient Compression for Face Verification” [10]，一篇关于如何使用高维度特征在人脸验证中的文章，作者主要以LBP（Local Binary Pattern，局部二值特征）为例子，论述了高维特征和验证性能存在着正相关的关系，即人脸维度越高，验证的准确度就越高。</p></li><li><p>深度学习  </p><p>  第三个阶段是基于深度学习的方法，自2012年深度学习在ILSVRC-2012大放异彩后，很多研究者都在尝试将其应用在自己的方向，这极大的推动了深度学习的发展。卷积神经网络在图像分类中显示出了巨大的威力，通过学习得到的卷积核明显优于人工设计的特征+分类器的方案。在人脸识别的研究者利用卷积神经网络（CNN）对海量的人脸图片进行学习，然后对输入图像提取出对区分不同人的脸有用的特征向量，替代人工设计的特征。</p><p>  在前期，研究人员在网络结构、输入数据的设计等方面尝试了各种方案，然后送入卷积神经网络进行经典的目标分类模型训练；在后期，主要的改进集中在损失函数上，即迫使卷积网络学习得到对分辨不同的人更有效的特征，这时候人脸识别领域彻底被深度学习改造了！</p><p>  DeepFace[11]是CVPR2014上由Facebook提出的方法，是深度卷积神经网络在人脸识别领域的奠基之作，文中使用了3D模型来做人脸对齐任务，深度卷积神经网络针对对齐后的人脸Patch进行多类的分类学习，使用的是经典的交叉熵损失函数（Softmax）进行问题优化，最后通过特征嵌入（Feature Embedding）得到固定长度的人脸特征向量。Backbone网络使用了多层局部卷积结构（Local Convolution），原因是希望网络的不同卷积核能学习人脸不同区域的特征，但会导致参数量增大，要求数据量很大，回过头去看该策略并不是十分必要。<br>  DeepFace在LFW上取得了97.35%的准确率，已经接近了人类的水平。之后Google推出FaceNet（<a href="https://arxiv.org/abs/1503.03832" target="_blank" rel="noopener">Facenet论文地址</a>），使用三元组损失函数(Triplet Loss)代替常用的Softmax交叉熵损失函数，在一个超球空间上进行优化使类内距离更紧凑，类间距离更远，最后得到了一个紧凑的128维人脸特征，其网络使用GoogLeNet的Inception模型，模型参数量较小，精度更高，在LFW上取得了99.63%的准确率，这种损失函数的思想也可以追溯到早期的LDA算法。<br>  CVPR2014、CVPR2015香港中文大学汤晓鸥团队提出的DeepID系列是一组非常有代表性的工作，其中DeepID1[12]使用四层卷积，最后一层为Softmax，中间为Deep Hidden Identity Features，是学习到的人脸特征表示，并使用Multi-patch分别训练模型最后组合成高维特征，人脸验证阶段使用联合贝叶斯的方法；通过学习一个多类（10000类，每个类大约有20个实例）人脸识别任务来学习特征，文中指出，随着训练时要预测的人脸类越多，DeepID的泛化能力就越强。</p></li></ul><h1 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h1><h2 id="算法仓库"><a href="#算法仓库" class="headerlink" title="算法仓库"></a><strong>算法仓库</strong></h2><ul><li><p>ageitgey/face_recognition:  </p><p>  <a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">https://github.com/ageitgey/face_recognition</a>  </p></li><li><p>davidsandberg/facenet:  </p><p>  <a href="https://github.com/davidsandberg/facenet" target="_blank" rel="noopener">https://github.com/davidsandberg/facenet</a>  </p></li><li><p>cmusatyalab/openface:  </p><p>  <a href="https://github.com/cmusatyalab/openface" target="_blank" rel="noopener">https://github.com/cmusatyalab/openface</a> </p></li><li><p>kpzhang93/MTCNN_face_detection_alignment(人脸检测):  </p><p>  <a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">https://github.com/kpzhang93/MTCNN_face_detection_alignment</a>  </p></li><li><p>deepinsight/insightface:  </p><p>  <a href="https://github.com/deepinsight/insightface" target="_blank" rel="noopener">https://github.com/deepinsight/insightface</a>  </p></li><li><p>nyoki-mtl/keras-facenet:  </p><p>  <a href="https://github.com/nyoki-mtl/keras-facenet" target="_blank" rel="noopener">https://github.com/nyoki-mtl/keras-facenet</a>  </p></li><li><p>yuyang-huang/keras-inception-resnet-v2(网络结构):</p><p>  <a href="https://github.com/yuyang-huang/keras-inception-resnet-v2" target="_blank" rel="noopener">https://github.com/yuyang-huang/keras-inception-resnet-v2</a></p></li></ul><p><strong>相关博客</strong></p><ul><li><p>应用一个基于Python的开源人脸识别库，face_recognition:<br><a href="https://blog.csdn.net/hongbin_xu/article/details/76284134" target="_blank" rel="noopener">https://blog.csdn.net/hongbin_xu/article/details/76284134</a>  </p></li><li><p>TensorFlow–实现人脸识别实验精讲 （Face Recognition using Tensorflow）:<br><a href="https://blog.csdn.net/niutianzhuang/article/details/79191167" target="_blank" rel="noopener">https://blog.csdn.net/niutianzhuang/article/details/79191167</a>  </p></li><li><p>基于卷积神经网络和tensorflow实现的人脸识别:<br><a href="https://blog.csdn.net/hy13684802853/article/details/79780805" target="_blank" rel="noopener">https://blog.csdn.net/hy13684802853/article/details/79780805</a></p></li><li><p>keras/构建卷积神经网络人脸识别:</p><p>  <a href="https://blog.csdn.net/szj_huhu/article/details/75202254" target="_blank" rel="noopener">https://blog.csdn.net/szj_huhu/article/details/75202254</a></p></li><li><p>人脸识别–(opencv、dlib、keras-TensorFlow）:<br><a href="https://blog.csdn.net/u014258362/article/details/80688224" target="_blank" rel="noopener">https://blog.csdn.net/u014258362/article/details/80688224</a>  </p></li><li><p>TensorFlow实现人脸识别(5)——-利用训练好的模型实时进行人脸检测:<br><a href="https://blog.csdn.net/yunge812/article/details/79447584" target="_blank" rel="noopener">https://blog.csdn.net/yunge812/article/details/79447584</a>  </p></li><li><p>基于keras的人脸识别:<br><a href="https://blog.csdn.net/Julymycin/article/details/79182222" target="_blank" rel="noopener">https://blog.csdn.net/Julymycin/article/details/79182222</a>  </p></li><li><p>史上最全的FaceNet源码使用方法和讲解（一）（附预训练模型下载）:<br><a href="https://blog.csdn.net/u013044310/article/details/79556099" target="_blank" rel="noopener">https://blog.csdn.net/u013044310/article/details/79556099</a><br><a href="https://github.com/boyliwensheng/understand_facenet(作者整理代码)" target="_blank" rel="noopener">https://github.com/boyliwensheng/understand_facenet(作者整理代码)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36416906，如有侵权，请联系删除。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/36416906，如有侵权，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="人脸识别" scheme="http://yoursite.com/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs与Django的跨域问题</title>
    <link href="http://yoursite.com/2018/07/08/Nodejs%E4%B8%8EDjango%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/08/Nodejs与Django的跨域问题/</id>
    <published>2018-07-08T12:23:10.000Z</published>
    <updated>2018-07-09T00:38:12.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nodejs与Django的跨域问题"><a href="#Nodejs与Django的跨域问题" class="headerlink" title="Nodejs与Django的跨域问题"></a>Nodejs与Django的跨域问题</h2><p>由于采用前后端分离的编程方式，Django的csrf_token验证失效，出现跨域问题，在此记录一下解决方法。</p><ul><li><p>1 安装django-cors-headers  </p><p>  pip install django-cors-headers</p></li></ul><ul><li>2 配置settings.py文件<br><img src="/2018/07/08/Nodejs与Django的跨域问题/跨域问题模块.png" alt="Nodejs与Django的跨域问题">  </li></ul><p><img src="/2018/07/08/Nodejs与Django的跨域问题/跨域问题设置.png" alt="Nodejs与Django的跨域问题">  </p><p>OK！问题解决！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nodejs与Django的跨域问题&quot;&gt;&lt;a href=&quot;#Nodejs与Django的跨域问题&quot; class=&quot;headerlink&quot; title=&quot;Nodejs与Django的跨域问题&quot;&gt;&lt;/a&gt;Nodejs与Django的跨域问题&lt;/h2&gt;&lt;p&gt;由于采用前后
      
    
    </summary>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Django使用MongoDB数据库</title>
    <link href="http://yoursite.com/2018/07/08/Django%E4%BD%BF%E7%94%A8MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/08/Django使用MongoDB数据库/</id>
    <published>2018-07-08T12:22:47.000Z</published>
    <updated>2018-07-08T12:37:45.470Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习使用Django搭建在线教育平台使用的是Mysql数据库，现在考虑到公司以后的发展及当前技术需求，更换为MongoDB数据库。在此记录一下更改操作：  </p><ul><li><p>1 首先安装mongoengine，并在setting中设置对应的位置  </p><p>  pip instal mongoengine</p></li></ul><p><img src="/2018/07/08/Django使用MongoDB数据库/installs安装内容.png" alt="数据库设置"></p><ul><li>2 设置默认的数据库信息  </li></ul><p><img src="/2018/07/08/Django使用MongoDB数据库/数据库设置.png" alt="数据库设置">  </p><ul><li>3 设置Model</li></ul><p><img src="/2018/07/08/Django使用MongoDB数据库/model设置.png" alt="数据库设置">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之前因为使用Django自带的admin后台管理系统，所以在像Mysql一样迁移数据库时出现错误。后来分析发现，目前使用Django所做的工作不需要用到后台管理系统，仅仅是作为一个后台服务，因此可直接运行。至此，设置完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前学习使用Django搭建在线教育平台使用的是Mysql数据库，现在考虑到公司以后的发展及当前技术需求，更换为MongoDB数据库。在此记录一下更改操作：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 首先安装mongoengine，并在setting中设置对应的位置  &lt;/p
      
    
    </summary>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7为firewalld添加开放端口及相关操作</title>
    <link href="http://yoursite.com/2018/07/05/CentOS7%E4%B8%BAfirewalld%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/05/CentOS7为firewalld添加开放端口及相关操作/</id>
    <published>2018-07-05T13:32:17.000Z</published>
    <updated>2018-07-08T12:39:48.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="firewalld的基本使用"><a href="#firewalld的基本使用" class="headerlink" title="firewalld的基本使用"></a>firewalld的基本使用</h3><pre><code>启动： systemctl start firewalld查看状态： systemctl status firewalld 停止： systemctl disable firewalld禁用： systemctl stop firewalld</code></pre><h3 id="systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。"><a href="#systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。" class="headerlink" title="systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。"></a>systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</h3><pre><code>启动一个服务：systemctl start firewalld.service关闭一个服务：systemctlstop firewalld.service重启一个服务：systemctlrestart firewalld.service显示一个服务的状态：systemctlstatus firewalld.service在开机时启用一个服务：systemctlenable firewalld.service在开机时禁用一个服务：systemctldisable firewalld.service查看服务是否开机启动：systemctlis-enabled firewalld.service查看已启动的服务列表：systemctllist-unit-files|grep enabled查看启动失败的服务列表：systemctl--failed</code></pre><h3 id="配置firewalld-cmd"><a href="#配置firewalld-cmd" class="headerlink" title="配置firewalld-cmd"></a>配置firewalld-cmd</h3><pre><code>查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd--zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息:  firewall-cmd--get-active-zones查看指定接口所属区域： firewall-cmd--get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic</code></pre><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><pre><code>firewall-cmd --zone=public --add-port=80/tcp --permanent   （--permanent永久生效，没有此参数重启后失效）</code></pre><h4 id="重新载入"><a href="#重新载入" class="headerlink" title="重新载入"></a>重新载入</h4><pre><code>firewall-cmd --reload</code></pre><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><pre><code>firewall-cmd --zone=public --query-port=80/tcp</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>firewall-cmd --zone=public --remove-port=80/tcp --permanent</code></pre><h3 id="查看firewall是否运行-下面两个命令都可以"><a href="#查看firewall是否运行-下面两个命令都可以" class="headerlink" title="查看firewall是否运行,下面两个命令都可以"></a>查看firewall是否运行,下面两个命令都可以</h3><pre><code>systemctl status firewalld.servicefirewall-cmd --state</code></pre><h3 id="查看当前开了哪些端口"><a href="#查看当前开了哪些端口" class="headerlink" title="查看当前开了哪些端口"></a>查看当前开了哪些端口</h3><p>其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。</p><pre><code>firewall-cmd --list-services</code></pre><h3 id="查看还有哪些服务可以打开"><a href="#查看还有哪些服务可以打开" class="headerlink" title="查看还有哪些服务可以打开"></a>查看还有哪些服务可以打开</h3><pre><code>firewall-cmd --get-services</code></pre><h3 id="查看所有打开的端口："><a href="#查看所有打开的端口：" class="headerlink" title="查看所有打开的端口："></a>查看所有打开的端口：</h3><pre><code>firewall-cmd --zone=public --list-ports</code></pre><h3 id="更新防火墙规则："><a href="#更新防火墙规则：" class="headerlink" title="更新防火墙规则："></a>更新防火墙规则：</h3><pre><code>firewall-cmd --reload</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;firewalld的基本使用&quot;&gt;&lt;a href=&quot;#firewalld的基本使用&quot; class=&quot;headerlink&quot; title=&quot;firewalld的基本使用&quot;&gt;&lt;/a&gt;firewalld的基本使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;启动： systemctl 
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CentOS7" scheme="http://yoursite.com/tags/CentOS7/"/>
    
      <category term="firewalld" scheme="http://yoursite.com/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs与Django图片信息传输</title>
    <link href="http://yoursite.com/2018/07/05/Nodejs%E4%B8%8EDjango%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2018/07/05/Nodejs与Django图片信息传输/</id>
    <published>2018-07-05T13:11:22.000Z</published>
    <updated>2018-07-07T07:44:44.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nodejs与Django图片信息传输"><a href="#Nodejs与Django图片信息传输" class="headerlink" title="Nodejs与Django图片信息传输"></a>Nodejs与Django图片信息传输</h2><p>由于公司需要Nodejs的前端与Django的后端进行交互，其中涉及到图片信息作为二进制流传输，在此记录前后端分离中二进制图片在Django中的保存与转换。</p><hr><h3 id="Nodejs中的数据传输"><a href="#Nodejs中的数据传输" class="headerlink" title="Nodejs中的数据传输"></a>Nodejs中的数据传输</h3><p><strong>Nodejs采用Input插件读取图片</strong>  </p><p><img src="/2018/07/05/Nodejs与Django图片信息传输/提交图片.png" alt="提交图片"></p><p><strong>其中涉及到公司大牛写的Webship框架，但传送数据的方式没有大的改变</strong>  </p><p><img src="/2018/07/05/Nodejs与Django图片信息传输/前端传输数据格式.png" alt="前端传输数据格式"></p><h3 id="Django保存传输的二进制图片"><a href="#Django保存传输的二进制图片" class="headerlink" title="Django保存传输的二进制图片"></a><strong>Django保存传输的二进制图片</strong></h3><p>首先，我们分析request请求中所包含的信息：  </p><p><img src="/2018/07/05/Nodejs与Django图片信息传输/查看request内容.png" alt="查看request内容"><br>通过分析，发现request中FILES属性是前端发给我们的包含图片信息的内容，我们取出FILES属性中的内容赋值给files，再进行分析，看我们需要的图片究竟是什么样的内容和格式，内容如下：  </p><p><img src="/2018/07/05/Nodejs与Django图片信息传输/将request的file属性.png" alt="将request的file属性">  </p><p>可以发现，files变量中包含name属性，即我提交的图片名字，还有一个file属性，其是一个bytes格式的变量入口，这个可能就是我需要的二进制图片，经过测试，读取这个file属性得到的二进制流和我以‘rb’模式read()提交的同一个图片所得到的二进制流相等。<br><strong>至此，就找到了requst中所包含的图片信息，然后将其保存到指定路径中：</strong>  </p><p><img src="/2018/07/05/Nodejs与Django图片信息传输/读取内存中的二进制流文件.png" alt="读取内存中的二进制流文件">  </p><p><strong>完成！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nodejs与Django图片信息传输&quot;&gt;&lt;a href=&quot;#Nodejs与Django图片信息传输&quot; class=&quot;headerlink&quot; title=&quot;Nodejs与Django图片信息传输&quot;&gt;&lt;/a&gt;Nodejs与Django图片信息传输&lt;/h2&gt;&lt;p&gt;由于
      
    
    </summary>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Django文档——Model字段类型</title>
    <link href="http://yoursite.com/2018/06/14/Django%E6%96%87%E6%A1%A3%E2%80%94%E2%80%94Model%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/14/Django文档——Model字段类型/</id>
    <published>2018-06-14T09:13:15.000Z</published>
    <updated>2018-06-14T09:27:24.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字段类型-Field-types"><a href="#字段类型-Field-types" class="headerlink" title="字段类型(Field types)"></a>字段类型(Field types)</h1><h3 id="AutoField"><a href="#AutoField" class="headerlink" title="AutoField"></a>AutoField</h3><p>它是一个根据 ID 自增长的 IntegerField 字段。通常，你不必直接使用该字段。如果你没在别的字段上指定主 键，Django 就会自动添加主键字段。</p><h3 id="BigIntegerField"><a href="#BigIntegerField" class="headerlink" title="BigIntegerField"></a>BigIntegerField</h3><p>64位整数，类似于IntegerField，范围从-9223372036854775808 到9223372036854775807。默认的form widget 是TextInput。</p><h3 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h3><p>一个布尔值(true/false)字段。</p><p>默认的form widget是CheckboxInput。</p><p>如果要使用null作为空值，可使用NullBooleanField。</p><h3 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h3><pre><code>class CharField(max_length=None[, **options])</code></pre><p>它是一个字符串字段，对小字符串和大字符串都适用。</p><p>对于更大的文本，应该使用TextField 。</p><p>默认的form widget是TextInput。</p><p>CharField 有一个必须传入的参数：max_length,字段的最大字符数。它作用于数据库层级和 Django 的数据验证层级。</p><h3 id="CommaSeparatedInterField"><a href="#CommaSeparatedInterField" class="headerlink" title="CommaSeparatedInterField"></a>CommaSeparatedInterField</h3><p>class CommaSeparatedIntegerField(max_length=None[, **options])</p><p>它用来存放以逗号间隔的整数序列。和 CharField 一样，必须为它提供 max_length 参数。而且要注意不同数据库对 max_length 的限制。</p><h3 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h3><pre><code>class DateField([auto_now=False, auto_now_add=False, **options])</code></pre><p>该字段利用 Python 的 datetime.date 实例来表示日期。下面是它额外的可选参数：</p><p>DateField.auto_now：每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示 “最后修改” 时间。要注意使用的是当前日期，而并非默认值，所以</p><p>不能通过重写默认值的办法来改变保存时间。</p><p>DateField.auto_now_add：在第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。它使用的同样是当前日期，而非默认值。</p><p>默认的form widget是TextInput。</p><p>Note:当auto_now或者auto_now_add设置为True时，字段会有editable=True和blank=True的设定。</p><h3 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h3><pre><code>class DateTimeField([auto_now=False, auto_now_add=False, **options])</code></pre><p>该字段利用 datetime.datetime 实例表示日期和时间。该字段所按受的参数和 DateField 一样。</p><p>默认的form widget是TextInput。Django 的admin使用两个带有 JavaScript 快捷选项TextInput分别表示日期和时间。</p><h3 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h3><pre><code>class DecimalField(max_digits=None, decimal_places=None[, **options])</code></pre><p>它是使用 Decimal 实例表示固定精度的十进制数的字段。它有两个必须的参数：</p><p>DecimalField.max_digits：数字允许的最大位数</p><p>DecimalField.decimal_places：小数的最大位数</p><p>例如，要存储的数字最大值是999，而带有两个小数位，你可以使用：</p><p>1<br>models.DecimalField(…, max_digits=5, decimal_places=2)<br>要存储大约是十亿级且带有10个小数位的数字，就这样写：</p><p>1<br>models.DecimalField(…, max_digits=19, decimal_places=10)<br>默认的form widget是TextInput。</p><h3 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h3><pre><code>class EmailField([max_length=75, **options])</code></pre><p>它是带有 email 合法性检测的A CharField 。</p><p>Note：最大长度默认为75，并不能存储所有与RFC3696/5321兼容的email地址。如果要存储所有，请设置 </p><p>max_length=254。设置为75是历史遗留问题。</p><h3 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a>FileField</h3><pre><code>class FileField(upload_to=None[, max_length=100, **options])</code></pre><p>文件上传字段</p><p>Note：该字段不支持 primary_key 和 unique 参数，否则会抛出 TypeError 异常。</p><p>它有一个必须的参数：</p><p>FileField.upload_to</p><p>用于保存文件的本地文件系统。它根据 MEDIA_ROOT 设置确定该文件的 url 属性。</p><p>该路径可以包含 时间格式串strftime()，可以在上传文件的时候替换成当时日期／时间(这样，就不会出现在上传文件把某个目录塞满的情况了)。</p><p>该参数也可以是一个可调用项，比如是一个函数，可以调用函数获得包含文件名的上传路径。这个可调用项必须要接受两个参数，</p><p>并且返回一个保存文件用的 Unix-Style 的路径(用 / 斜杠)。两个参数分别是：</p><pre><code>instance ：定义了当前 FileField 的 model 实例。更准确地说，就是以该文件为附件的 model 实例。</code></pre><p>大多数情况下，在保存该文件时， model 实例对象还并没有保存到数据库，这是因为它很有可能使用默认的 AutoField，而此时它还没有从数据库中获得主键值。</p><pre><code>filename ：上传文件的原始名称。在生成最终路径的时候，有可能会用到它。</code></pre><p>还有一个可选的参数：</p><p>FileField.storage</p><p>负责保存和获取文件的对象。</p><p>默认的form widget是FileInput。</p><p>Note：在 model 中使用 FileField 或 ImageField 要按照以下的步骤：</p><p>1.在项目settings文件中，你要定义 MEDIA_ROOT ，将它的值设为用来存放上传文件的目录的完整路径。(基于性能的考虑，Django 没有将文件保存在数据库中).</p><p>然后定义 MEDIA_URL ，将它的值设为表示该目录的网址。 </p><p>要确保 web 服务器所用的帐号拥有对该目录的写权限。</p><p>2.在 model 里面添加 FileField 或 ImageField ，并且确认已定义了 upload_to 项，让 Django 知道应该用 </p><p>MEDIA_ROOT 的哪个子目录来保存文件。</p><p>3.存储在数据库当中的仅仅只是文件的路径(而且是相对于 MEDIA_ROOT 的相对路径)。你可能已经想到利用 </p><p>Django 提供的 url 这个方便的属性。举个例子，如果你的 ImageField 名称是 mug_shot，那么你可以在模板 </p><p>中使用</p><p>1<br><br>就能得到图片的完整网址。</p><p>例如，假设你的 MEDIA_ROOT 被设为 ‘/home/media’，upload_to 被设为 ‘photos/%Y/%m/%d’。 upload_to 中 </p><p>的 ‘%Y/%m/%d’ 是一个strftime()， ‘%Y’ 是四位的年份，’%m’ 是两位的月份， ‘%d’ 是两位的日子。如果你 </p><p>在2007年01月15号上传了一个文件，那么这个文件就保存在 /home/media/photos/2007/01/15 目录下。</p><p>如果你想得到上传文件的本地文件名称，文件网址，或是文件的大小，你可以使用 name, url 和 size 属性。</p><p>Note：在上传文件时，要警惕保存文件的位置和文件的类型，这么做的原因是为了避免安全漏洞。对每一个上传 </p><p>文件都要验证，这样你才能确保上传的文件是你想要的文件。举个例子，如果你盲目地让别人上传文件，而没有 </p><p>对上传文件进行验证，如果保存文件的目录处于 web 服务器的根目录下，万一有人上传了一个 CGI 或是 PHP </p><p>脚本，然后通过访问脚本网址来运行上传的脚本，那可就太危险了。千万不要让这样的事情发生！</p><p>默认情况下，FileField 实例在数据库中的对应列是 varchar(100) ，和其他字段一样，你可以利用max_length 参数改变字段的最大长度。</p><p>FileField and FieldFile<br>  class FieldFile</p><p>当你访问一个Model的FileField字段时，会得到一个FieldFile的实例作为代理去访问底层文件。实例有几种属性和方法可以用来和文件数据进行互动。</p><p>FieldFile.url</p><p>通过只读的方式调用底层存储(Storage)类的 url() 方法，来访问该文件的相对URL。</p><p>FieldFile.open(mode=’rb’)</p><p>类似于python的open()方法。</p><p>FieldFile.close()</p><p>类似于python的close()方法。</p><p>FieldFile.save(name,content,save=True)</p><p>这种方法将filename和文件内容传递到该字段然后存储到该模型。该方法需要两个必须的参数：name， 文件的名称， content， 包含文件内容的对象。save 参数是可选的，主 </p><p>要是控制文件修改后实例是否保存。默认是 True 。需要注意的是，content 参数是 django.core.files.File 的一个实例，不是Python的内置File对象。你可以使 </p><p>用他从现有的Python文件对象中构建一个文件，如下所示：</p><p>1<br>2<br>3<br>4<br>from django.core.files import File</p><h1 id="Open-an-existing-file-using-Python’s-built-in-open"><a href="#Open-an-existing-file-using-Python’s-built-in-open" class="headerlink" title="Open an existing file using Python’s built-in open()"></a>Open an existing file using Python’s built-in open()</h1><p>f = open(‘/tmp/hello.world’)<br>myfile = File(f)<br>或者从字符串中构造：</p><p>1<br>2<br>from django.core.files.base import ContentFile<br>myfile = ContentFile(“hello world”)<br>FieldFile.delete(save=True)</p><p>删除此实例相关的文件，并清除该字段的所有属性。</p><p>Note：当delete()被调用时，如果文件正好是打开的，该方法将关闭文件。</p><p>save 参数是可选的，控制文件删除后实例是否保存。默认是 True 。</p><p>需要注意的是，当一个模型被删除时，相关文件不被删除。如果想删除这些孤立的文件，需要自己去处理（比如，可以手动运行命令清理，也可以通过cron来定期执行清理命令）</p><p>FilePathField<br>class FilePathField(path=None[, match=None, recursive=False, max_length=100, **options])</p><p>它是一个 CharField ，它用来选择文件系统下某个目录里面的某些文件。它有三个专有的参数，只有第一个参 </p><p>数是必须的：</p><p>FilePathField.path</p><p>这个参数是必需的。它是一个目录的绝对路径，而这个目录就是 FilePathField 用来选择文件的那个目录。比 </p><p>如： “/home/images”.</p><p>FilePathField.match</p><p>可选参数。它是一个正则表达式字符串， FilePathField 用它来过滤文件名称，只有符合条件的文件才出现在 </p><p>文件选择列表中。要注意正则表达式只匹配文件名，而不是匹配文件路径。例如：”foo.*.txt$” 只匹配名为 </p><p>foo23.txt 而不匹配 bar.txt 和 foo23.gif。</p><p>FilePathField.recursive</p><p>可选参数。它的值是 True 或 False。默认值是 False。它指定是否包含 path 下的子目录。</p><p>FilePathField.allow_files</p><p>该项属于Django1.5新增内容。可选参数，它的值是 True 或 False。默认值是 True。它指定是否包含指定位置的文件。该项与allow_folders 必须有一个是 True。</p><p>FilePathField.allow_folders</p><p>Django1.5新增内容。可选参数，它的值是True或False。默认是False。它指定是否包含指定位置的目录。该项与allow_files必须有一个是 True。</p><p>前面已经提到了 match 只匹配文件名称，而不是文件路径。所以下面这个例子：</p><p>1<br>FilePathField(path=”/home/images”, match=”foo.*”, recursive=True)<br>将匹配 /home/images/foo.gif ，而不匹配 /home/images/foo/bar.gif。这是因为 match 只匹配文件名<br>(foo.gif 和 bar.gif).</p><p>默认情况下， FilePathField 实例在数据库中的对应列是varchar(100) 。和其他字段一样，你可以利用 max_length 参数改变字段的最大长度。</p><h3 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h3><pre><code>class FloatField([**options])</code></pre><p>该字段在 Python 中使用float 实例来表示一个浮点数。</p><p>默认的form widget是TextInput。</p><p>请注意FloatField与DecimalField的区别。</p><h3 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a>ImageField</h3><pre><code>class ImageField(upload_to=None[, height_field=None, width_field=None, max_length=100,**options])</code></pre><p>和 FileField 一样，只是会验证上传对象是不是一个合法的图象文件。</p><p>除了那些在 FileField 中有效的参数之外， ImageField 还可以使用 File.height and File.width 两个属性 。</p><p>它有两个可选参数：</p><p>ImageField.height_field</p><p>保存图片高度的字段名称。在保存对象时，会根据该字段设定的高度，对图片文件进行缩放转换。</p><p>ImageField.width_field</p><p>保存图片宽度的字段名称。在保存对象时，会根据该字段设定的宽度，对图片文件进行缩放转换。</p><p>默认情况下， ImageField 实例对应着数据库中的varchar(100) 列。和其他字段一样，你可以使 用 max_length 参数来改变字段的最大长度。</p><h3 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h3><pre><code>class IntegerField([**options])</code></pre><p>整数字段。默认的form widget是TextInput。</p><h3 id="IPAddressField"><a href="#IPAddressField" class="headerlink" title="IPAddressField"></a>IPAddressField</h3><pre><code>class IPAddressField([**options])</code></pre><p>以字符串形式(比如 “192.0.2.30”)表示 IP 地址字段。默认的form widget是TextInput。</p><h3 id="GenericIPAddressField"><a href="#GenericIPAddressField" class="headerlink" title="GenericIPAddressField"></a>GenericIPAddressField</h3><pre><code>class GenericIPAddressField([**options])</code></pre><p>Django1.4新增。</p><p>以字符串形式(比如 “192.0.2.30”或者”2a02:42fe::4”)表示 IP4或者IP6 地址字段。默认的form widget是TextInput。</p><p>IPv6的地址格式遵循RFC 4291 section 2.2。比如如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示，例如 “::ffff:192.0.2.0”。</p><p>2001:0::0:01可以写成2001::1,而::ffff:0a0a:0a0a可以写成::ffff:10.10.10.10。字母都为小写。</p><p>GenericIPAddressField.protocol</p><p>验证输入协议的有效性。默认值是 ‘both’ 也就是IPv4或者IPv6。该项不区分大小写。</p><p>GenericIPAddressField.unpack_ipv4</p><p>解释IPv4映射的地址，像   ::ffff:192.0.2.1  。如果启用该选项，该地址将必解释为 192.0.2.1 。默认是禁止的。只有当 protocol 被设置为 ‘both’ 时才可以启用。</p><h3 id="NullBooleanField"><a href="#NullBooleanField" class="headerlink" title="NullBooleanField"></a>NullBooleanField</h3><pre><code>class NullBooleanField([**options])</code></pre><p>与 BooleanField 相似，但多了一个 NULL 选项。建议用该字段代替使用 null=True 选项的 BooleanField 。 </p><p>默认的form widget是NullBooleanSelect。</p><h3 id="PositiveIntegerField"><a href="#PositiveIntegerField" class="headerlink" title="PositiveIntegerField"></a>PositiveIntegerField</h3><pre><code>class PositiveIntegerField([**options])</code></pre><p>和 IntegerField 相似，但字段值必须是非负数。</p><h3 id="PositiveSmallIntegerField"><a href="#PositiveSmallIntegerField" class="headerlink" title="PositiveSmallIntegerField"></a>PositiveSmallIntegerField</h3><pre><code>class PositiveSmallIntegerField([**options])</code></pre><p>和 PositiveIntegerField 类似，但数值的取值范围较小，受限于数据库设置。</p><h3 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h3><pre><code>class SlugField([max_length=50, **options])</code></pre><p>Slug 是一个新闻术语，是指某个事件的短标签。它只能由字母，数字，下划线或连字符组成。通赏情况下，它被用做网址的一部分。</p><p>和 CharField 类似，你可以指定 max_length (要注意数据库兼容性和本节提到的 max_length )。如果没有指定 max_length ，Django 会默认字段长度为50。</p><p>该字段会自动设置 Field.db_index to True。</p><p>基于其他字段的值来自动填充 Slug 字段是很有用的。你可以在 Django 的管理后台中使用prepopulated_fields 来做到这一点。</p><h3 id="SmallIntegerField"><a href="#SmallIntegerField" class="headerlink" title="SmallIntegerField"></a>SmallIntegerField</h3><pre><code>class SmallIntegerField([**options])</code></pre><p>和 IntegerField 类似，但数值的取值范围较小，受限于数据库的限制。</p><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><pre><code>class TextField([**options])</code></pre><p>大文本字段。默认的form widget是Textarea。</p><h3 id="TimeField"><a href="#TimeField" class="headerlink" title="TimeField"></a>TimeField</h3><pre><code>class TimeField([auto_now=False, auto_now_add=False, **options])</code></pre><p>该字段使用 Python 的 datetime.time 实例来表示时间。它和 DateField 接受同样的自动填充的参数。</p><p>默认的form widget是TextInput。</p><h3 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h3><pre><code>class URLField([max_length=200, **options])</code></pre><p>保存 URL 的 CharField 。</p><p>和所有 CharField 子类一样，URLField 接受可选的 max_length 参数，该参数默认值是200。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字段类型-Field-types&quot;&gt;&lt;a href=&quot;#字段类型-Field-types&quot; class=&quot;headerlink&quot; title=&quot;字段类型(Field types)&quot;&gt;&lt;/a&gt;字段类型(Field types)&lt;/h1&gt;&lt;h3 id=&quot;AutoFie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>点滴积累</title>
    <link href="http://yoursite.com/2018/06/11/%E7%82%B9%E6%BB%B4%E7%A7%AF%E7%B4%AF/"/>
    <id>http://yoursite.com/2018/06/11/点滴积累/</id>
    <published>2018-06-11T12:42:01.000Z</published>
    <updated>2018-07-14T12:42:53.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo生成博文插入图片"><a href="#hexo生成博文插入图片" class="headerlink" title="hexo生成博文插入图片"></a>hexo生成博文插入图片</h2><ol><li>把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true  </li><li>在你的hexo目录下执行这样一句话npm install hexo-asset-image –save  </li><li>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹  </li><li><p>最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：  </p><ul><li>! [你想输入的替代文字](xxxx/图片名.jpg)</li></ul></li></ol><ul><li><strong>注意：</strong> xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。  </li></ul><h2 id="Error-That-port-is-already-in-use-的错误。"><a href="#Error-That-port-is-already-in-use-的错误。" class="headerlink" title="Error: That port is already in use.的错误。"></a>Error: That port is already in use.的错误。</h2><p>即端口号已经被占用,说明servr已经在运行了(也有可能在后台运行)  </p><p>那么找到该进程,kill掉即可.  </p><p>或者最简单的解决方法就是：  </p><p>在终端输入 sudo fuser -k 8000/tcp  </p><p>这样和端口8000相关的进程就都关了。</p><h2 id="Centos下实现word转pdf"><a href="#Centos下实现word转pdf" class="headerlink" title="Centos下实现word转pdf"></a>Centos下实现word转pdf</h2><p>libreoffice –headless –invisible –convert-to pdf 模版123.docx –outdir /filepath</p><h2 id="爆破大数据平台"><a href="#爆破大数据平台" class="headerlink" title="爆破大数据平台"></a>爆破大数据平台</h2><h3 id="Nodejs后端"><a href="#Nodejs后端" class="headerlink" title="Nodejs后端"></a>Nodejs后端</h3><ul><li><p>1 创建数据库  </p><ol><li>1 使用redis、mongodb</li><li>2 使用Mysql  其中有DATATIME属性    </li></ol></li></ul><ul><li><p>2 使用Admzip以及正则表达式实现文档的替换</p></li><li><p>3 将生成的文档转换为PDF</p></li></ul><h3 id="Django后端"><a href="#Django后端" class="headerlink" title="Django后端"></a>Django后端</h3><ul><li>1 设计Model</li><li>2 前后端分离传递数据</li><li>3 算法的嵌入</li></ul><h3 id="涉及算法"><a href="#涉及算法" class="headerlink" title="涉及算法"></a>涉及算法</h3><ul><li><p>1 图像识别</p></li><li><p>2 自动布孔</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo生成博文插入图片&quot;&gt;&lt;a href=&quot;#hexo生成博文插入图片&quot; class=&quot;headerlink&quot; title=&quot;hexo生成博文插入图片&quot;&gt;&lt;/a&gt;hexo生成博文插入图片&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;把主页配置文件_config.yml 里的pos
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="日常记录" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>机器学习——EM算法</title>
    <link href="http://yoursite.com/2018/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/10/机器学习——EM算法/</id>
    <published>2018-06-10T11:18:20.000Z</published>
    <updated>2018-06-11T13:37:57.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><h2 id="EM简介"><a href="#EM简介" class="headerlink" title="EM简介"></a>EM简介</h2><p>EM(Expectation Mmaximization) 是一种迭代算法， 用于含隐变量(Latent Variable) 的概率模型参数的极大似然估计， 或极大后验概率估计 EM算法由两步组成， 求期望的E步，和求极大的M步。<br>EM算法可以看成是特殊情况下计算极大似然的一种算法。现实的数据经常有一些比较奇怪的问题，比如缺失数据、含有隐变量等问题。当这些问题出现的时候，计算极大似然函数通常是比较困难的，而EM算法可以解决这个问题。</p><p>EM算法已经有很多应用，比如最经典的Hidden Markov模型等。经济学中，除了逐渐开始受到重视的HMM模型（例如Yin and Zhao, 2015），其他领域也有可能涉及到EM算法，比如在Train的《Discrete Choice Methods with Simulation》就给出了一个 $mixed logit$ 模型的EM算法。</p><h2 id="EM算法的预备知识"><a href="#EM算法的预备知识" class="headerlink" title="EM算法的预备知识"></a>EM算法的预备知识</h2><ol><li><p>极大似然估计</p><ol><li><p>1  举例说明：经典问题——学生身高问题  </p><p>我们需要调查我们学校的男生和女生的身高分布。 假设你在校园里随便找了100个男生和100个女生。他们共200个人。将他们按照性别划分为两组，然后先统计抽样得到的100个男生的身高。假设他们的身高是服从高斯分布的。但是这个分布的均值u和方差∂2我们不知道，这两个参数就是我们要估计的。记作θ=[u, ∂]T。<br>问题：我们知道样本所服从的概率分布的模型和一些样本，而不知道该模型中的参数。<br>我们已知的有两个：（1）样本服从的分布模型（2）随机抽取的样本  需要通过极大似然估计求出的包括：模型的参数<br>总的来说：极大似然估计就是用来估计模型参数的统计学方法。 </p></li><li><p>2  如何估计  </p><p>问题数学化：</p></li></ol><ul><li>(1)样本集: x={$x_1,x_2,…,x_N$}, $N=100$。</li><li>(2)概率密度：$p(x_i|\theta)$ 抽到男生$i$（的身高）的概率 100个样本之间独立同分布，所以我同时抽到这100个男生的概率就是他们各自概率的乘积。就是从分布是$p(x|\theta)$ 的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：<br>$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$<br>这个概率反映了，在概率密度函数的参数是$\theta$时，得到X这组样本的概率。 需要找到一个参数θ，其对应的似然函数$L(\theta)$最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做$\theta$的最大似然估计量，记为<br>$$argmaxL(\theta)$$  </li></ul><ol start="3"><li><p>3  求最大似然函数估计值的一般步骤  </p><p>首先，写出似然函数：<br>$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$<br>其次，对似然函数取对数，并整理：<br>$$H(\theta)=lnL(\theta)=ln\prod_{i=1}^n{p(x_i|\theta)}=\sum_{i=1}^n{lnp(x_i|\theta)}$$<br>然后，求导数，令导数为0，得到似然方程；最后，解似然方程，得到的参数即为所求。</p></li><li><p>4  总结  </p><p>多数情况下我们是根据已知条件来推算结果，而极大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。</p></li></ol></li></ol><p><img src="/2018/06/10/机器学习——EM算法/797505-20160401125718941-1997034466.png" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EM算法&quot;&gt;&lt;a href=&quot;#EM算法&quot; class=&quot;headerlink&quot; title=&quot;EM算法&quot;&gt;&lt;/a&gt;EM算法&lt;/h1&gt;&lt;h2 id=&quot;EM简介&quot;&gt;&lt;a href=&quot;#EM简介&quot; class=&quot;headerlink&quot; title=&quot;EM简介&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS环境搭建</title>
    <link href="http://yoursite.com/2018/06/05/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/06/05/CentOS环境搭建/</id>
    <published>2018-06-05T11:13:28.000Z</published>
    <updated>2018-06-06T10:00:56.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h2 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h2><ol><li>微星1080Ti</li><li>至强E5 -2620v4</li><li><p>技嘉的主板</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p>将CentOS 7.4镜像刻到U盘之后，向服务器安装时，使用U盘启动会出现两种启动选项，一种是UEFI启动选项，一种是默认的启动选项，如果不使用UEFI方式安装，那么一般是没有问题的，如果选择UEFI方式安装系统，那么引导系统时会出现如下的提示：</p><p> [sdb] No Caching mode page found</p><p> [sdb] Assuming drive cache:write through</p><p> Could not boot  /dev/root does not exist</p></li></ol><p>　　然后命令行就卡在这了，现在只需要耐心等待，等一会之后会不断的滚动错误警告，这个时候继续等待，那么一会就会出来命令行输入界面，这个时候输入以下命令：</p><pre><code>ls /dev/sd*</code></pre><p>　　输入命令之后会列出所有的存储设备，这个时候一般情况下第一块硬盘是sda，如果有多个分区，那么依次就是sda1、sda2等等，如果有两块硬盘那么就是sdb，U盘一般是排最后的号，如果有一块硬盘，那么U盘就是sdb，如果有两块硬盘，那么U盘就是sdc，U盘一般会有sdc和sdc4两个选项，sdc属于U盘存储，sdc4就是镜像所在分区了，这样一般是没有问题的，如果出现问题，那么接下来多配置几次就好了，接下来输入命令reboot重启计算机，在安装界面，先不要选择安装，这个时候按一下e键，会进入编辑界面，移动光标进行如下修改：</p><p>　　在第二行默认是：vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</p><p>　　把这行修改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4:/ quiet</p><p>　　就是把hd:和quiet之间的内容修改为U盘镜像所在位置这样就可以了，注意要写成/dev/sdc4:/</p><p>　　然后根据提示按Ctrl+X键就可以开始安装了，现在就正常进入安装界面了</p><h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><p>1、在官网上<a href="http://www.geforce.cn/drivers搜索到对应型号的显卡驱动并下载，下载到的驱动文件是一个后缀名为.run的文件（例如NVIDIA-Linux-x86_64-384.98.run）；" target="_blank" rel="noopener">http://www.geforce.cn/drivers搜索到对应型号的显卡驱动并下载，下载到的驱动文件是一个后缀名为.run的文件（例如NVIDIA-Linux-x86_64-384.98.run）；</a></p><p>2、安装gcc编译环境以及内核相关的包：<br>    yum install kernel-devel kernel-doc kernel-headers gcc* glibc*  glibc-*<br>注意：安装内核包时需要先检查一下当前内核版本是否与所要安装的kernel-devel/kernel-doc/kernel-headers的版本一致，请务必保持两者版本一致，否则后续的编译过程会出问题。</p><p>3、禁用系统默认安装的 nouveau 驱动，修改/etc/modprobe.d/blacklist.conf 文件：  </p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><pre><code>echo -e &quot;blacklist nouveau\noptions nouveau modeset=0&quot; &gt; /etc/modprobe.d/blacklist.conf</code></pre><h3 id="备份原来的镜像文件"><a href="#备份原来的镜像文件" class="headerlink" title="备份原来的镜像文件"></a>备份原来的镜像文件</h3><pre><code>mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak</code></pre><h3 id="重建新镜像文件"><a href="#重建新镜像文件" class="headerlink" title="重建新镜像文件"></a>重建新镜像文件</h3><pre><code>dracut /boot/initramfs-$(uname -r).img $(uname -r)</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>reboot  </code></pre><h3 id="在命令行界面"><a href="#在命令行界面" class="headerlink" title="在命令行界面"></a>在命令行界面</h3><pre><code>init 5 </code></pre><h3 id="查看nouveau是否启动，如果结果为空即为禁用成功"><a href="#查看nouveau是否启动，如果结果为空即为禁用成功" class="headerlink" title="查看nouveau是否启动，如果结果为空即为禁用成功"></a>查看nouveau是否启动，如果结果为空即为禁用成功</h3><pre><code>lsmod | grep nouveau</code></pre><p>4、安装DKMS模块</p><p>DKMS全称是DynamicKernel ModuleSupport，它可以帮我们维护内核外的驱动程序，在内核版本变动之后可以自动重新生成新的模块。  </p><pre><code>sudo yum install DKMS  </code></pre><p>5、执行显卡驱动安装脚本（如果内核版本一致，就不需要指定–kernel-source-path和-k）  </p><pre><code>./NVIDIA-Linux-x86_64-384.98.run --kernel-source-path=/usr/src/kernels/3.10.0-693.11.1.el7.x86_64/ -k $(uname -r) --dkms -s</code></pre><p>6、若步骤5执行过程中没报错，则安装成功。重启，执行nvidia-smi可查看相关信息。<br>如若出现重启系统驱动找不到的情况，在装完驱动后，切记，先不要重启，使用</p><pre><code>init5</code></pre><p>和  </p><pre><code>init 3</code></pre><p>交替切换，几次后，会进入图形界面（其中init 5为进入图形界面的命令），之后，在图形界面，重新编译一下启动项。</p><h1 id="CUDA-amp-amp-CUDNN"><a href="#CUDA-amp-amp-CUDNN" class="headerlink" title="CUDA&amp;&amp;CUDNN"></a>CUDA&amp;&amp;CUDNN</h1><p>　　关于cuda和cudnn的安装，这一点尤其要注意。我在CentOS7.5(更新后的版本，初始装的时候为7.4)上安装CUDA9.2时，无法与NVIDIA的驱动匹配，因此退而求其次，选择了CUDA9.1，同时CUDNN选择7.0.5版本。<br><strong>注意</strong> 不要下载cudnn-9.1-linux-ppc64le-v7.1.tgz，因为ppc64le并不是针对X64的电脑系统<br>CUDA的安装我选择了使用yum安装的方式，因为之前使用命令行，出现了未知的错误，导致系统重装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统安装&quot;&gt;&lt;a href=&quot;#系统安装&quot; class=&quot;headerlink&quot; title=&quot;系统安装&quot;&gt;&lt;/a&gt;系统安装&lt;/h1&gt;&lt;h2 id=&quot;电脑配置&quot;&gt;&lt;a href=&quot;#电脑配置&quot; class=&quot;headerlink&quot; title=&quot;电脑配置&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习的东西</title>
    <link href="http://yoursite.com/2018/05/30/%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2018/05/30/计划/</id>
    <published>2018-05-30T07:38:48.000Z</published>
    <updated>2018-07-11T12:20:53.749Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX19W5wcU0Ueb+0OwRwPk2XXJr0Er97J/hxTNnb7pW+PHI+EX1QFZvw668xHNvBA0LkyXAxQu+/PQTgFpfAy+AywNdsoh4TmCGQ1KRI4HUeZlY8moGGCStwfJOrhXDgDNjPAd8lw5VIkz9ScIHuFDnrzWyRVACsxPTV1MLH9cKMauf2+734TSxEMK+W+Cb0a6CMsBPpaIjpLF5Yzr1sdsPncYjVG7UQFqk8tU2pfZo9qeHUWTHf5YOk2Xaq1MFbiFCkAi4AuQksL9u2F/+D3a20L8GnHCkngy5i3J0XA9AnOMt1zmc37ni2zJIZOJZZ+tRWcufZaXDhrsGSEgstKmnbt/yjSxCC8wKZ1Z3FPgGqBTp9aa1EdyErFpiXJt8yq9z8UCyQwfGUUsOZwofzWlLxZtf34YT5JLr5Q6roWpaSpS5bfDXyYqbIRfpTJgcm/57ibj1jZBKSK/L3LTdk7sSFThqTHEkVDqvAUCsrXpasQa7Yqo7k/yaxg40G+SMs5TCu8iVoKLrvCx7/iXz8Mk62zU8f9zag/NBZWQOMtY0grvAq6qY3ykhjImwG9nqrPTv/5csic6OX1diwunW7o2ktX8ZjtnwUmi4GvMQ4D24l0lm/jpAOoRE+9xaYLC/pfzanEE0vEtOOsVu3leDs6gjicIibGLdQXEv8OmrovWDBionhm8kX+enh+LoaTYx0HKB4VI0KVKGPY1sp+54Ahm4LOmLbKulqOkUBxpFJR3UjLfKyCLp7BhWqJvlqzJ0UdStQdWS0+O2VVo367a2k9iqoOvWTiDauzVfZcGfSLjMRypKtfMp9YLVv3XigVNPnbjHbg2HKRWkdmGwuAiXkFAqGFBmYPY4dlrf5T4kjO9xsc9S1IWEe6vm43uMX59oDkhGoUATik0pElwQnYNMLvFNqJ/jTQ18JFz8ED5ZVC9sgiyyD8PnFo7Hm1ZWXFcpj78dX+5LzqrWsCMiegjYtKjtN0pW+AfRO1LMz8BDQhMRlq1IMW/Jcxug6C7HGA9QGYNa/0gEgca4KMNJVrhVZXR6tcw1gzIeJ/yhNHnwgriFYGVFsl3jXnLBP89KCT+tZF+whV78/GMER0X+Zk9ReoAqrNt0UwZsbM3WPOMaWA4sVSTZxLo9FYpNxyXVu2IhDUlk2VL/cb1VTHTqBAS+mc2ZSyQrCn1z1VnjKmFZMfOuOFYUFFgDe4e7hVuJl5/wu3tsO8w49QJQyNDSCJJi/itHU7sEy9ZQYA0Wcwp85fWbJ/LuVLE3mA9UdXUpanVBC3gf3sdU+uvenKLf9GHMctzTjpZ7/dEAnwyn+zvXPxZGLxdMiAmf3ai1oCs4+rh+DQcSpcchXDsQlMWmn9O6znx2WGVQHwsShPGkIdxFpsMcJ6Mtt2kzz8FWO+AkyjKNlU5TRHl0+5R58WaZ/JGTYQ2iiOKVUEBd7+YblMdbBtyzRAm1+q8CITlbzpbU82S/0qqMdV3EcG623F6VDma21Ih42pyMM5SqzK578F40t4uFTOE5p9rw8ELrvxMC9ON7ajbCn1ce2THyvzzR04todY2ehLgMrMKnQ7AiKIpEpbBBfEjS7/PxN2pzNjlRduDMSkvJkvbXxsQaDNULIlCCSv5/AQdPVKxy8Pb0AHJ1zvYSBnOzyJOIcF/Cs5oSMcjeeiykXv/leNqo4veLrwAHzdibvV88CRxeqm4V4OAwrDHqqECnptNkJYk7uWSt9eNHrRtq62i4DDuLnb2y6f571B/RQLZZLfqad+B+w/hHi6ME20kHztMHT01ktpZNzGAKKS4D5tLJJmpasI02/fWUGBcv625Dz7KQgLsspzsSu8IHvV736y4/23uI1CwGtCAsBjhQ7CiUvnqro25Etfc01R0t/uA4N1YzIYfXa0=</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=/js/crypto-js.js&gt;&lt;/script&gt;
&lt;script&gt;
function doDecrypt (pwd, onError) {
	console.log(&#39;in doDecrypt&#39;);
	const txt = document.getE
      
    
    </summary>
    
      <category term="自省" scheme="http://yoursite.com/categories/%E8%87%AA%E7%9C%81/"/>
    
    
      <category term="坚持" scheme="http://yoursite.com/tags/%E5%9D%9A%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>Django的网站逻辑</title>
    <link href="http://yoursite.com/2018/05/29/Django%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/05/29/Django实战/</id>
    <published>2018-05-29T07:38:48.000Z</published>
    <updated>2018-06-04T03:59:00.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django实战——后台逻辑"><a href="#Django实战——后台逻辑" class="headerlink" title="Django实战——后台逻辑"></a>Django实战——后台逻辑</h1><h2 id="Django用户-（登录-注册-找回密码）"><a href="#Django用户-（登录-注册-找回密码）" class="headerlink" title="Django用户 （登录 注册 找回密码）"></a>Django用户 （登录 注册 找回密码）</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><hr><p>后台的操作放在对应app的views文件下，当我们在路由中添加一个url，django会自动为我们生成一个request，<br>并添加到<br>函数里面。首先判断请求方法，是POST还是GET。然后跳转到对应的页面进行操作。  </p><h4 id="对登录账户进行验证（采用类来做）"><a href="#对登录账户进行验证（采用类来做）" class="headerlink" title="对登录账户进行验证（采用类来做）"></a>对登录账户进行验证（采用类来做）</h4><ol><li>得到用户名和密码后，使用django.contrib.auth.authenticate进行验证，验证成功的话得到一个对象，<br>然后进行对应后台逻辑的编写，即调用django.contrib.auth.login进行验证。  </li><li>对登录成功后返回index.html文件的状态处理，需要在html文件中进行判断，用户是否登录，调用<br>request.user.user.is_authenticated来进行判断。决定显示哪一行代码。</li><li>自定义认证方法，实现邮箱的登录方式（重定义方式）</li></ol><h4 id="Seesion和Cookie机制"><a href="#Seesion和Cookie机制" class="headerlink" title="Seesion和Cookie机制"></a>Seesion和Cookie机制</h4><ol><li>无状态请求</li><li>有状态请求 </li></ol><hr><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><hr><h4 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h4><ol><li>添加插件（captcha）</li></ol><h4 id="提交注册信息（包括注册码）"><a href="#提交注册信息（包括注册码）" class="headerlink" title="提交注册信息（包括注册码）"></a>提交注册信息（包括注册码）</h4><h4 id="发送邮件验证注册信息"><a href="#发送邮件验证注册信息" class="headerlink" title="发送邮件验证注册信息"></a>发送邮件验证注册信息</h4><h4 id="激活账户"><a href="#激活账户" class="headerlink" title="激活账户"></a>激活账户</h4><hr><h3 id="找回密码"><a href="#找回密码" class="headerlink" title="找回密码"></a>找回密码</h3><hr><p>采用类似于激活账户的方式来实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django实战——后台逻辑&quot;&gt;&lt;a href=&quot;#Django实战——后台逻辑&quot; class=&quot;headerlink&quot; title=&quot;Django实战——后台逻辑&quot;&gt;&lt;/a&gt;Django实战——后台逻辑&lt;/h1&gt;&lt;h2 id=&quot;Django用户-（登录-注册-找
      
    
    </summary>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Adm-zip工具</title>
    <link href="http://yoursite.com/2018/05/29/Adm-zip%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/05/29/Adm-zip工具/</id>
    <published>2018-05-29T01:12:01.000Z</published>
    <updated>2018-06-14T09:20:45.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Adm-zip介绍"><a href="#Adm-zip介绍" class="headerlink" title="Adm-zip介绍"></a>Adm-zip介绍</h3><hr><p><strong>Adm-zip是JavaScript中的一款与压缩文件相关的插件，其功能相当的强大（我看来），我用其实现了对Word文档的内容替换。</strong></p><font color="#00099ff" face="黑体">Word 文档本质上是一个压缩 文件夹，其中的word文件夹下的document.xml文件是包含文档内容的文件，而我们需要操作的也正是这个文件。</font><font color="#00099ff" face="微软雅黑">Adm-zip这款插件则正好满足我们即对压缩文件内部条目文件的处理，同时又保证不影响压缩文件内部其余文件的要求。</font>  <font face="黑体">我们需要的函数接口主要有四个，分别为：</font>  <p>读取压缩文件内指定目录里面的文件或者文件夹：  </p><pre><code>Admzip.readAsText()  </code></pre><p>删除压缩文件内的指定文件或者文件夹：</p><pre><code>Admzip.deleteFile()  </code></pre><p>将指定文件写入到压缩文件夹中：</p><pre><code>Admzip.addFile()  </code></pre><p>将所做的更改重新写入文件（可以是当前文件，也可以重命名的word文档）</p><pre><code>Admzip.writeZip()</code></pre><p><strong>关于Adm-zip的使用方法，暂时只发现了这样一种，其还有别的Api接口，有兴趣的小伙伴可以自己再研究下^_^</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Adm-zip介绍&quot;&gt;&lt;a href=&quot;#Adm-zip介绍&quot; class=&quot;headerlink&quot; title=&quot;Adm-zip介绍&quot;&gt;&lt;/a&gt;Adm-zip介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Adm-zip是JavaScript中的一款与压缩文件相关
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Adm-zip" scheme="http://yoursite.com/tags/Adm-zip/"/>
    
  </entry>
  
  <entry>
    <title>MARKDOWN语法熟悉</title>
    <link href="http://yoursite.com/2018/05/28/MARKDOWN%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89/"/>
    <id>http://yoursite.com/2018/05/28/MARKDOWN语法熟悉/</id>
    <published>2018-05-28T09:03:28.000Z</published>
    <updated>2018-07-13T07:38:07.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="标题测试"><a href="#标题测试" class="headerlink" title="标题测试"></a><strong>标题测试</strong></h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h2><h3 id="未换行"><a href="#未换行" class="headerlink" title="未换行"></a>未换行</h3><p>未换行测试<br>示例</p><h3 id="换行后"><a href="#换行后" class="headerlink" title="换行后"></a>换行后</h3><p>已换行测试（后有两个空格）<br>示例</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>分段测试</p><p>分段</p><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><p><strong>加粗(使用两个*号)</strong><br><em>斜体（使用一个</em>号）*<br><del>删除线(使用两个波浪线)</del><br>‘底纹（单引号）’</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。</p><p>无序列表： 在文本前加 「 <em> 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）<br>在 「 </em> 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。<br>有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。<br>注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>1  </li><li>2  <ul><li>2.1  <ul><li>2.1.1  <ul><li>2.1.1.1</li></ul></li></ul></li></ul></li><li>3</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>1</li><li>2<br> a. 2.1<br> b. 2.2</li><li>3</li></ol><h3 id="有序列表与无序列表混排"><a href="#有序列表与无序列表混排" class="headerlink" title="有序列表与无序列表混排"></a>有序列表与无序列表混排</h3><ol><li>1</li><li>2<br> a. 2.1<br> b. 2.2<pre><code>* 2.2.1</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。</p><blockquote><p>这是引用文本</p></blockquote><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="http://mouapp.com/Mou_128.png" alt="Mou icon"></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a></p><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>三个「 - 」或「 * 」都可以画出一条水平分割线</p><hr><p>使用（—）的水平分割线</p><hr><p>使用（***）的水平分割线</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>两对「 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码前加四个空格键  </span><br><span class="line">代码前加一个 tab 键</span><br><span class="line"></span><br><span class="line">### 两对‘ ``` ’包裹</span><br><span class="line"></span><br><span class="line">```print(&apos;Hello Word!&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="四个空格"><a href="#四个空格" class="headerlink" title="四个空格"></a>四个空格</h3><pre><code>print(&apos;Hello Word!&apos;);</code></pre><h3 id="一个-tab-键"><a href="#一个-tab-键" class="headerlink" title="一个 tab 键"></a>一个 tab 键</h3><pre><code>print(&apos;Hello Word!&apos;);</code></pre><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。</p><p>点击右上方的小数字有注解$[^1]$<br>    $[^1] :$这里是注解<br>这是随机文本<br>这是随机文本<br>这是随机文本  </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br><!--注释，无法预览--></p><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？在输入法的「全角」模式下，输入两个空格键即可。  </p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>在网页上写文章建议使用直角引号『「」』。  </p><hr><hr><h1 id="利用Markdown创建表格"><a href="#利用Markdown创建表格" class="headerlink" title="利用Markdown创建表格"></a>利用Markdown创建表格</h1><p>Markdown作为一种轻量级书写/写作语言，并没有提供很好的排版、编辑等功能。因此，如果想要利用Markdown创建表格（特别是复杂表格），其实是一项不太轻松的事情。<br>经过笔者在简书平台上的测试与其他若干帖子的表述，Markdown应是只提供了最简单的创建表格与内容对齐方式的功能。总结而言，有如下两种最为直观的创建表格方式:</p><h3 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h3><pre><code>Name | Academy | score  - | :-: | -:  Harry Potter | Gryffindor| 90  Hermione Granger | Gryffindor | 100  Draco Malfoy | Slytherin | 90</code></pre><table><thead><tr><th>Name</th><th style="text-align:center">Academy</th><th style="text-align:right">score  </th></tr></thead><tbody><tr><td>Harry Potter</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">90  </td></tr><tr><td>Hermione Granger</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">100  </td></tr><tr><td>Draco Malfoy</td><td style="text-align:center">Slytherin</td><td style="text-align:right">90  </td></tr></tbody></table><h3 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h3><pre><code>| Name | Academy | score |  | - | :-: | -: |  | Harry Potter | Gryffindor| 90 |  | Hermione Granger | Gryffindor | 100 |  | Draco Malfoy | Slytherin | 90 |</code></pre><table><thead><tr><th>Name</th><th style="text-align:center">Academy</th><th style="text-align:right">score</th></tr></thead><tbody><tr><td>Harry Potter</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">90</td></tr><tr><td>Hermione Granger</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">100</td></tr><tr><td>Draco Malfoy</td><td style="text-align:center">Slytherin</td><td style="text-align:right">90</td></tr></tbody></table><h2 id="语法说明："><a href="#语法说明：" class="headerlink" title="语法说明："></a>语法说明：</h2><ol><li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； </li><li>列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 </li><li>可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</li></ol><p>这样傻瓜的表格创建方式十分符合Markdown简小精悍的语言气质，具有上手快、即学即用的优势。但傻瓜的定义方式显然不能满足很多处女座的要求，比如<br>文章——“Linux备忘录-Linux中文件/文件夹按照时间顺序升序/降序排列”的表格如下：</p><pre><code>| 参数 |详细解释|备注| | - | :-: | -: | | -l | use a long listing format |以长列表方式显示（显示出文件/文件夹详细信息） | | -t | sort by modification time |按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） | |-r | reverse order while sorting |逆序排列|  </code></pre><table><thead><tr><th>参数</th><th style="text-align:center">详细解释</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>-l</td><td style="text-align:center">use a long listing format</td><td style="text-align:right">以长列表方式显示（显示出文件/文件夹详细信息）</td></tr><tr><td>-t</td><td style="text-align:center">sort by modification time</td><td style="text-align:right">按照修改时间排序（默认最近被修改的文件/文件夹排在最前面）</td></tr><tr><td>-r</td><td style="text-align:center">reverse order while sorting</td><td style="text-align:right">逆序排列</td></tr></tbody></table><p>单元格排列不齐整、第一列太窄而第三列略宽，如此不堪的视觉效果着实让强迫症患者们难以忍受。还好，利用HTML可以弥补Markdown这一缺陷，甚至可以在创建表格时其他诸多表现方面锦上添花。</p><hr><hr><h1 id="Markdown-添加-MathJax-数学公式"><a href="#Markdown-添加-MathJax-数学公式" class="headerlink" title="Markdown 添加 MathJax 数学公式"></a>Markdown 添加 MathJax 数学公式</h1><p>添加公式的方法<br>行内公式</p><pre><code>$行内公式$</code></pre><p>行间公式</p><pre><code>$$行间公式$$</code></pre><h2 id="MathJax-数学公式语法"><a href="#MathJax-数学公式语法" class="headerlink" title="MathJax 数学公式语法"></a>MathJax 数学公式语法</h2><h3 id="呈现位置"><a href="#呈现位置" class="headerlink" title="呈现位置"></a>呈现位置</h3><p><strong>注意:</strong>  在公式的前一行和后一行，要注意空一行，否则公式会出错。</p><ul><li><p>所有公式定义格式为  </p><p>  \$…$</p></li><li><p>具体语句例如  </p><p>  \$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$<br>  显示为：  </p><p>  $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$  </p></li><li><p>居中并放大显示</p><p>  \$\$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$<br>  显示为：</p><p>  $$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</p></li></ul><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><table><thead><tr><th>显示</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th><th style="text-align:right">命令</th></tr></thead><tbody><tr><td>α</td><td style="text-align:center">\$\alpha\$</td><td style="text-align:center">β</td><td style="text-align:right">\$\beta\$</td></tr><tr><td>γ</td><td style="text-align:center">\$\gamma\$</td><td style="text-align:center">δ</td><td style="text-align:right">\$\delta\$</td></tr><tr><td>ϵ</td><td style="text-align:center">\$\epsilon\$</td><td style="text-align:center">ζ</td><td style="text-align:right">\$\zeta\$</td></tr><tr><td>η</td><td style="text-align:center">\$\eta\$</td><td style="text-align:center">θ</td><td style="text-align:right">\$\theta\$</td></tr><tr><td>ι</td><td style="text-align:center">\$\iota\$</td><td style="text-align:center">κ</td><td style="text-align:right">\$\kappa\$</td></tr><tr><td>λ</td><td style="text-align:center">\$\lambda\$</td><td style="text-align:center">μ</td><td style="text-align:right">\$\mu\$</td></tr><tr><td>ν</td><td style="text-align:center">\$\nu\$</td><td style="text-align:center">ξ</td><td style="text-align:right">\$\xi\$</td></tr><tr><td>π</td><td style="text-align:center">\$\pi\$</td><td style="text-align:center">ρ</td><td style="text-align:right">\$\rho\$</td></tr><tr><td>σ</td><td style="text-align:center">\$\sigma\$</td><td style="text-align:center">τ</td><td style="text-align:right">\$\tau\$</td></tr><tr><td>υ</td><td style="text-align:center">\$\upsilon\$</td><td style="text-align:center">ϕ</td><td style="text-align:right">\$\phi\$</td></tr><tr><td>χ</td><td style="text-align:center">\$\chi\$</td><td style="text-align:center">ψ</td><td style="text-align:right">\$\psi\$</td></tr><tr><td>ω</td><td style="text-align:center">\$\omega\$</td></tr></tbody></table><ul><li>如果需要大写的希腊字母，只需将命令的首字母大写即可(有的字母没有大写)，如<br>  \$\gamma$ &amp; \$\Gamma$</li></ul><p>$\gamma$ &amp; $\Gamma$</p><ul><li>若需要斜体希腊字母，在命令前加上var前缀即可(大写可斜)，如<br>  \$\Gamma$ &amp; \$\varGamma$  </li></ul><p>$\Gamma$ &amp; $\varGamma$</p><h3 id="字母修饰"><a href="#字母修饰" class="headerlink" title="字母修饰"></a>字母修饰</h3><h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h4><ul><li>上标：^  </li><li>下标：_  </li></ul><p>\$C_n^2$  </p><p>$$C_n^2$$</p><h4 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h4><ul><li>例1  </li></ul><p>\$\vec a$  </p><p>$\vec a$</p><ul><li>例2  </li></ul><p>\$\overrightarrow a$  </p><p>$\overrightarrow xy$</p><h4 id="字体-Typewriter"><a href="#字体-Typewriter" class="headerlink" title="字体 - Typewriter"></a>字体 - Typewriter</h4><p>\$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><p>$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><p>\$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><p>$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><p>\$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><p>$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  </p><h4 id="分组-有分组功能，如"><a href="#分组-有分组功能，如" class="headerlink" title="分组 - {}有分组功能，如"></a>分组 - {}有分组功能，如</h4><p>\$10^{10}\$ \&amp; \$10^10\$<br>$10^{10}$ &amp; $10^10$</p><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><ul><li>小括号：\$()$呈现为</li></ul><p>$()$  </p><ul><li>中括号：\$[]$呈现为</li></ul><p>$[]$  </p><ul><li>尖括号：\$\langle\rangle$呈现为</li></ul><p>$\langle\rangle$  </p><pre><code>- 此处为与分组符号{}相区别，使用转义字符\</code></pre><ul><li><p>使用\left(或\right)使符号大小与邻近的公式相适应；该语句适用于所有括号类型</p><ul><li><p>\$(\frac{x}{y})$呈现为</p><p>$(\frac{x}{y})$  </p></li><li><p>而\$\left(\frac{x}{y}\right)$呈现为</p><p>$\left(\frac{x}{y}\right)$</p></li></ul></li></ul><p><strong>注意:</strong> 在公式的前后，必须留有一个空格或者换行，否则无法识别。</p><h4 id="求和、极限与积分"><a href="#求和、极限与积分" class="headerlink" title="求和、极限与积分"></a>求和、极限与积分</h4><p>求和：\sum  </p><ul><li>举例：\$\sum_{i=1}^n{a_i}$  <ul><li>$\sum_{i=1}^n{a_i}$ </li></ul></li></ul><p>极限：\$\lim_{x\to 0}$  </p><ul><li>$\lim_{x\to 0}$ </li></ul><p>积分：\$\int$  </p><ul><li><p>$\int$  </p><p>  举例：\$\int_0^\infty{fxdx}$  </p><ul><li>$\int_0^\infty{fxdx}$  </li></ul></li><li><p>\$\iint$  $\iint$  </p></li><li>\$\iiint$  $\iiint$</li></ul><p>连乘：\$\prod$  </p><ul><li>$\prod$</li></ul><h4 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h4><p>分式(fractions)：\$\frac{公式1}{公式2}$  </p><ul><li>$\frac{公式1}{公式2}$  </li></ul><p>根式：\$\sqrt[x]{y}$</p><ul><li>$\sqrt[x]{y}$</li></ul><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><table><thead><tr><th>显示</th><th style="text-align:right">命令</th></tr></thead><tbody><tr><td>∞</td><td style="text-align:right">\$\infty$ </td></tr><tr><td>∪</td><td style="text-align:right">\$\cup$</td></tr><tr><td>∩</td><td style="text-align:right">\$\cap$ </td></tr><tr><td>⊂</td><td style="text-align:right">\$\subset$ </td></tr><tr><td>⊆</td><td style="text-align:right">\$\subseteq$ </td></tr><tr><td>⊃</td><td style="text-align:right">\$\supset$ </td></tr><tr><td>∈</td><td style="text-align:right">\$\in$ </td></tr><tr><td>∉</td><td style="text-align:right">\$\notin$ </td></tr><tr><td>∅</td><td style="text-align:right">\$\varnothing$ </td></tr><tr><td>∀</td><td style="text-align:right">\$\forall$</td></tr><tr><td>∃</td><td style="text-align:right">\$\exists$ </td></tr><tr><td>¬</td><td style="text-align:right">\$\lnot$ </td></tr><tr><td>∇</td><td style="text-align:right">\$\nabla$ </td></tr><tr><td>∂</td><td style="text-align:right">\$\partial$</td></tr></tbody></table><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ul><li>LaTeX语法本身会忽略空格的存在</li><li>小空格：\$a\ b$呈现为</li></ul><p>$a\ b$</p><ul><li>4格空格：\$a\quad b$呈现为</li></ul><p>$a\quad b$</p><h4 id="矩阵边框"><a href="#矩阵边框" class="headerlink" title="矩阵边框"></a>矩阵边框</h4><p>在起始、结束标记处用下列词替换matrix  </p><ul><li>pmatrix：小括号边框 </li><li>bmatrix：中括号边框 </li><li>Bmatrix：大括号边框 </li><li>vmatrix：单竖线边框 </li><li>Vmatrix：双竖线边框</li></ul><h4 id="省略元素"><a href="#省略元素" class="headerlink" title="省略元素"></a>省略元素</h4><p>横省略号：\cdots<br>竖省略号：\vdots<br>斜省略号：\ddots<br>举例  </p><pre><code>$$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\\                {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\\                {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\                {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\\                \end{bmatrix}$$</code></pre><p>$$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\<br>    {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\<br>    {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>    {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\<br>    \end{bmatrix}$$</p><h4 id="阵列"><a href="#阵列" class="headerlink" title="阵列"></a>阵列</h4><p>需要array环境：起始、结束处以{array}声明  </p><ul><li>对齐方式：在{array}后以{}逐行统一声明  </li><li>左对齐：l；居中：c；右对齐：r  </li><li>竖直线：在声明对齐方式时，插入|建立竖直线  </li><li>插入水平线：\hline</li></ul><p>方程组<br>需要cases环境：起始、结束处以{cases}声明<br>举例  </p><pre><code>$$\begin{cases}    a_1x+b_1y+c_1z=d_1\\\    a_2x+b_2y+c_2z=d_2\\\    a_3x+b_3y+c_3z=d_3\\\    \end{cases}$$</code></pre><p>$$\begin{cases}<br>    a_1x+b_1y+c_1z=d_1\\<br>    a_2x+b_2y+c_2z=d_2\\<br>    a_3x+b_3y+c_3z=d_3\\<br>    \end{cases}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;标题测试&quot;&gt;&lt;a href=&quot;#标题测试&quot; class=&quot;headerlink&quot; title=&quot;标题测试&quot;&gt;&lt;/a&gt;&lt;strong
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具 Markdown" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7-Markdown/"/>
    
  </entry>
  
  <entry>
    <title>第一个博客！</title>
    <link href="http://yoursite.com/2018/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%81/"/>
    <id>http://yoursite.com/2018/05/26/第一个博客！/</id>
    <published>2018-05-26T07:38:48.000Z</published>
    <updated>2018-06-14T09:20:20.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一个博客"><a href="#第一个博客" class="headerlink" title="第一个博客"></a>第一个博客</h3><h2 id="从这个博客开始，新的学习阶段开启了！"><a href="#从这个博客开始，新的学习阶段开启了！" class="headerlink" title="从这个博客开始，新的学习阶段开启了！"></a>从这个博客开始，新的学习阶段开启了！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一个博客&quot;&gt;&lt;a href=&quot;#第一个博客&quot; class=&quot;headerlink&quot; title=&quot;第一个博客&quot;&gt;&lt;/a&gt;第一个博客&lt;/h3&gt;&lt;h2 id=&quot;从这个博客开始，新的学习阶段开启了！&quot;&gt;&lt;a href=&quot;#从这个博客开始，新的学习阶段开启了！&quot; cla
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="NoteBook" scheme="http://yoursite.com/tags/NoteBook/"/>
    
  </entry>
  
</feed>
