<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MongoDB学习记录]]></title>
    <url>%2F2018%2F07%2F16%2FMongoDB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[MongoDB基本概念 文档 是键值对的有序集合，这是MongDB的核心概念 集合 集合就是一组文档 动态模式 集合是动态模式的，这意味着集合里面的文档可以是是各式各样的 命名 集合使用名称进行命名 数据库 由多个集合构成数据库，一个MongDB实例可以承载多个数据库，每个数据库拥有0个或多个集合 基本操作 在终端运行mongod命令，启动时，shell将自动连接MongDB数据库，需确保数据库已启动，可充分利用Javascript的标准库，还可定义和调用Javascript函数。 查看当前所处MongoDB db 选择数据库 use databases 如果数据库存在，则进入指定数据库，否则，创建数据库 此时需要写入数据，数据库才能真正创建成功 查看所有数据库 show databases | dbs 创建集合 db.createCollection(collection_name) 删除数据库 先进入要删除的数据库，然后执行命令 db.dropDatabase() 删除集合 db.collection_name.drop() 增 db.collection_name.insert(document) or: `db.students.insert({ name:&apos;James&apos;, age: 32, gender:&apos;man&apos;, career:&apos;player&apos; })` 查 db.collection.find(&lt;query&gt;,&lt;projection&gt;) query: 查询条件 projection: 投影操作 改 db.collection.updateOne(&lt;query&gt;,&lt;update&gt;) // 更新第一个符合条件的集合 db.collection.updateMany(&lt;query&gt;,&lt;update&gt;) // 更新所有符合条件的集合 query: 查询条件 update： 更新的内容 or:db.students.update({name:&#39;James&#39;},{$set:{gender:&#39;woman&#39;}}) 删 db.collection_name.deleteOne(&lt;query&gt;) // 删除第一个符合条件的集合 db.collection_name.deleteMany(&lt;query&gt;) // 删除所有符合条件的集合 or: db.students.deleteOne({name:&#39;James&#39;}) 数据操作（重点） 数据库的核心——CRUD，增加和删除较为简单，查询和修改较复杂 查询关系运算符 $gt 大于 $lt 小于 $gte 大于等于 $lte 小于等于 $eq | (key: value) 等于 $ne 不等于 先往数据库中添加一些数据 db.students.insert({&apos;name&apos;:&apos;张三&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;}) db.students.insert({&apos;name&apos;:&apos;李四&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:20,&apos;score&apos;: 100,&apos;address&apos;: &apos;朝阳区&apos;}) db.students.insert({&apos;name&apos;:&apos;王五&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:22,&apos;score&apos;: 50,&apos;address&apos;: &apos;西城区&apos;}) db.students.insert({&apos;name&apos;:&apos;赵六&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:21,&apos;score&apos;: 60,&apos;address&apos;: &apos;东城区&apos;}) db.students.insert({&apos;name&apos;:&apos;孙七&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:19,&apos;score&apos;: 70,&apos;address&apos;: &apos;海淀区&apos;}) db.students.insert({&apos;name&apos;:&apos;王八&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:23,&apos;score&apos;: 90,&apos;address&apos;: &apos;海淀区&apos;}) db.students.insert({&apos;name&apos;:&apos;刘九&apos;,&apos;sex&apos;:&apos;女&apos;,&apos;age&apos;:35,&apos;score&apos;: 56,&apos;address&apos;: &apos;朝阳区&apos;}) db.students.insert({&apos;name&apos;:&apos;钱十&apos;,&apos;sex&apos;:&apos;男&apos;,&apos;age&apos;:27,&apos;score&apos;: 89,&apos;address&apos;: &apos;海淀区&apos;}) exp: 查询姓名是张三的学生信息 db.students.find({name:’张三’}).pretty() 查询性别是男的学生信息 db.students.find({sex:’男’}).pretty() 查询年龄大于19岁的学生 db.students.find({age:{$gt:19}}).pretty() 查询成绩大于等于60分的学生 db.students.find({score:{$gte:60}}).pretty() 查询姓名不是王五的信息 db.students.find({name:{$ne:’王五’}}).pretty() 逻辑运算符 $and 与 $or 或 $not | $nor 非 exp: 查询年龄在19 ~ 22岁的学生信息 db.students.find({age:{$gte:19,$lte:22}}).pretty() 逻辑运算中与连接是最容易的，只需要利用,分割多个条件即可 查询年龄小于20岁，或者成绩大于90分的学生信息 db.students.find( {$or: [ {age:{$lt:20}}, {score:{$gt:90}} ] }).pretty() 查询年龄大于等于20岁，且成绩小于等于90分的学生信息 db.students.find( {$and: [ {age:{$gte:20}}, {score:{$lte:90}} ] }).pretty() 查询年龄小于20岁的学生信息 db.students.find({age:{$lt:20}}).pretty() db.students.find({age:{$not:{$gte:20}}}).pretty() 取模$mod:[除数，余数] exp: 查询年龄除以20余1的学生信息 db.students.find({age:{$mod:[20,1]}}).pretty() 范围查询$in: 在范围之中$nin: 不在范围之中 exp: 查询姓名是”张三“、”李四、”王五“的学生 db.students.find({name: {$in:[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]}}).pret ty() 查询姓名不是”张三“、”李四、”王五“的学生 db.students.find({name: {$nin:[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;]}}).pretty() 数组查询 $all $size $slice $elemMatch 首先在数据库中新增一些数据 db.students.insert({name:&apos;a&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]}) db.students.insert({name:&apos;b&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;]}) db.students.insert({name:&apos;c&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}) db.students.insert({name:&apos;d&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;]}) db.students.insert({name:&apos;e&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;,course:[&apos;语文&apos;,&apos;政治&apos;]}) $all: 表示全都包括，用法： {$all:[内容1,内容2]} exp: 查询同时参加语文和数学的学生 db.students.find({course:{$all:[&#39;语文&#39;,&#39;数学&#39;]}}).pretty() 数组的操作，可以利用索引，使用key.index的方式来定义索引 查询数组中第二个内容是数学的学生(sh) db.students.find({&#39;course.1&#39;:&#39;数学&#39;}).pretty() $size: 控制数组元素数量 exp: 查询只有两门课程的学生 db.students.find({course:{$size: 2}}).pretty() $slice: 控制查询结果的返回数量 exp: 查询年龄是19岁的学生，要求之显示两门参加的课程 db.students.find({age:19},{course:{$slice:2}}).pretty() 此时查询返回的是前两门课程，可以设置参数来取出想要的内容 $slice:-2 //后两门 $slice: [1,2] // 第一个参数表示跳过的数据量，第二个参数表示返回的数据量 嵌套集合运算对象里面套对象 在数据库中新增数据 db.students.insert( { name:&apos;A&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;, course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;,&apos;音乐&apos;,&apos;政治&apos;], parents:[ {name:&apos;A(father)&apos;,age:50,job:&apos;工人&apos;}, {name:&apos;A(mother)&apos;,age:50,job:&apos;职员&apos;} ] }) db.students.insert( { name:&apos;B&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;, course:[&apos;语文&apos;,&apos;数学&apos;], parents:[ {name:&apos;B(father)&apos;,age:50,job:&apos;处长&apos;}, {name:&apos;B(mother)&apos;,age:50,job:&apos;局长&apos;} ] }) db.students.insert( { name:&apos;C&apos;,sex:&apos;男&apos;,age:19,score:89,address:&apos;海淀区&apos;, course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;], parents:[ {name:&apos;C(father)&apos;,age:50,job:&apos;工人&apos;}, {name:&apos;C(mother)&apos;,age:50,job:&apos;局长&apos;} ] }) 对于嵌套的集合中数据的判断只能通过$elemMatch完成 语法：{ &lt;field&gt;: { $elemMatch: { &lt;query1&gt;, &lt;query2&gt;, ... } } } exp: 查询父母中有人是局长的信息 db.students.find({parents: {$elemMatch: {job: &#39;局长&#39;}}}).pretty() 判断某个字段是否存在{$exists:flag} flag为true表示存在，false表示不存在 exp: 查询具有parents成员的学生 db.students.find({parents:{$exists: true}}).pretty() 查询不具有course成员的学生 db.students.find({course: {$exists: false}}).pretty() 排序sort({ field: value }) value是1表示升序，-1表示降序 exp: 学生信息按照分数降序排列 db.students.find().sort({score:-1}).pretty() 分页显示skip(n): 跳过n条数据 limit(n): 返回n条数据 exp: 分页显示，第一页，每页显示5条数据 db.students.find({}).skip(0).limit(5).pretty() 分页显示，第二页，每页显示5条数据 db.students.find({}).skip(5).limit(5).pretty() 数据修改 | 更新updateOne() 修改匹配的第一条数据 updateMany() 修改所有匹配的数据 格式：updateOne(&lt;filter&gt;,&lt;update&gt;) 修改器$inc: 操作数字字段的数据内容 语法: {&quot;$inc&quot; : {成员 : 内容}} exp: 将所有年龄为19岁的学生成绩一律减少30分，年龄增加1 db.students.updateMany({age:19},{$inc:{score:-30,age:1}}) $set: 更新内容 语法：{$set: :{属性: 新内容}} exp: 将20岁学生的成绩修改为89 db.students.updateMany({age: 20},{$set: {score: 89}}) $unset: 删除某个属性及其内容 语法：{$unset: {属性: 1}} exp: 删除张三的年龄和成绩信息 db.students.updateOne({name:&apos;张三&apos;},{$unset: {age: 1,score: 1}}) $push: 向数组中添加数据 语法：{$push: {属性: value}} exp: 在李四的课程中添加语文 db.students.updateOne({name: &apos;李四&apos;},{$push: {course: &apos;语文&apos;}}) 如果需要向数组中添加多个数据，则需要用到$each exp: 在李四的课程中添加数学、英语 db.students.updateOne( {name:&apos;李四&apos;}, {$push: { course:{$each: [&apos;数学&apos;,&apos;英语&apos;]} } } ) $addToSet: 向数组里面添加一个新的数据 与$push的区别，$push添加的数据可能是重复的，$addToSet只有这个数据不存在时才会添加（去重） 语法：{$addToSet: {属性：value}} exp: 王五新增一门舞蹈课程 db.students.updateOne( {name:&apos;王五&apos;}, {$addToSet: {course:&apos;舞蹈&apos;}} ) $pop: 删除数组内的数据 语法：{$pop: {field: value}},value为-1表示删除第一个，value为1表示删除最后一个 exp: 删除王五的第一个课程 db.students.updateOne({name:&apos;王五&apos;},{$pop:{course:-1}}) 只是删除属性的内容，属性还在 $pull: 从数组中删除一个指定内容的数据 语法：{$pull: {field：value}} 进行数据比对，如果是该数据则删除 exp: 删除李四的语文课程 db.students.updateOne({name: &apos;李四&apos;},{$pull:{course:&apos;语文&apos;}}) $pullAll: 一次删除多个数据 语法：{$pullAll:{field:[value1,value2...]}} exp: 删除a的语文数学英语课程 db.students.updateOne({name:&apos;a&apos;},{$pullAll:{course:[&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]}}) $rename: 属性重命名 语法： {$rename: {旧属性名：新属性名}} exp: 把张三的name属性名改为姓名 db.students.updateOne({name:&apos;张三&apos;},{$rename:{name:&apos;姓名&apos;}})]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facenet详解]]></title>
    <url>%2F2018%2F07%2F14%2Ffacenet%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[facenet算法初测 facenet代码地址 数据对齐详解 已训练模型下载(基于CASIA-WebFace) 主要参考博客 算法代码结构结构如图： |—— contribute (包含对人脸进行处理的函数) |—— data (原算法进行训练或测试时使用的图片数据) |—— lfw (储存的lfw数据集) |—— lfw_mtcnnpy_160 (储存的经过对齐后的图片数据) |—— models (存储训练模型) |—— src (核心功能相关的代码) |—— test (算法、模型测试相关的代码) |—— tmp (暂不清楚) |—— 其他 功能测试 预训练模型测试： python src/validate_on_lfw.py lfw_mtcnnpy_160 models\20180408-102900 然而测试结果并不是特别好，可能是仅用CPU的缘故 相似人脸对比结果： python src\compare.py models\20180408-102900 data\images\Anthony_Hopkins_0001.jpg data\images\Anthony_Hopkins_0002.jpg 不相似人脸对比结果： python src\compare.py models\20180408-102900 data\images\Anthony_Hopkins_0001.jpg lfw_mtcnnpy_160\Aaron_Eckhart\Aaron_Eckhart_0001.png]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>facenet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript使用记录]]></title>
    <url>%2F2018%2F07%2F12%2FJavaScript%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现： function callback() { console.log(&apos;Done&apos;); } console.log(&apos;before setTimeout()&apos;); setTimeout(callback, 1000); // 1秒钟后调用callback函数 console.log(&apos;after setTimeout()&apos;); 观察上述代码执行，在Chrome的控制台输出可以看到： before setTimeout() after setTimeout() (等待1秒后) Done 可见，异步操作会在将来的某个时间点触发一个函数调用。 AJAX就是典型的异步操作。以之前的代码为例： request.onreadystatechange = function () { if (request.readyState === 4) { if (request.status === 200) { return success(request.responseText); } else { return fail(request.status); } } } 把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。 有没有更好的写法？比如写成这样： var ajax = ajaxGet(&apos;http://...&apos;); ajax.ifSuccess(success) .ifFail(fail); 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。 古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。 我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;); setTimeout(function () { if (timeOut &lt; 1) { log(&apos;call resolve()...&apos;); resolve(&apos;200 OK&apos;); } else { log(&apos;call reject()...&apos;); reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;); } }, timeOut * 1000); } 这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve(‘200 OK’)，如果执行失败，我们将调用reject(‘timeout in ‘ + timeOut + ‘ seconds.’)。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。 有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果： var p1 = new Promise(test); var p2 = p1.then(function (result) { console.log(&apos;成功：&apos; + result); }); var p3 = p2.catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); 变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象： // 如果成功，执行这个函数： p1.then(function (result) { console.log(&apos;成功：&apos; + result); }); 当test函数执行失败时，我们告诉Promise对象： p2.catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); Promise对象可以串联起来，所以上述代码可以简化为： new Promise(test).then(function (result) { console.log(&apos;成功：&apos; + result); }).catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了： Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2F2018%2F07%2F12%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转载自https://blog.csdn.net/zwhfyy/article/details/8625228，如有侵权，请联系删除 出错信息Your local changes to the following files would be overwritten by mergeerror: Your local changes to the following files would be overwritten by merge: 123.txtPlease, commit your changes or stash them before you can merge. 如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下: git stash git pull git stash pop 然后可以使用git diff -w +文件名 来确认代码自动合并的情况. 反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下: git reset --hard git pull 其中git reset是针对版本,如果想针对文件回退本地修改,使用]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人脸识别算法发展情况]]></title>
    <url>%2F2018%2F07%2F10%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E5%8F%91%E5%B1%95%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[转载自https://zhuanlan.zhihu.com/p/36416906，如有侵权，请联系删除。 人脸识别概述人脸识别的目标是确定一张人脸图像的身份，即这个人是谁，这是机器学习和模式识别中的分类问题。它主要应用在身份识别和身份验证中。 人脸识别系统的组成人脸检测（Face Detection） 人脸对齐（Face Alignment） 人脸特征表征（Feature Representation） 人脸检测 人脸检测用于确定人脸在图像中的大小和位置，即解决“人脸在哪里”的问题，把真正的人脸区域从图像中裁剪出来，便于后续的人脸特征分析和识别。 人脸对齐 同一个人在不同的图像序列中可能呈现出不同的姿态和表情，这种情况是不利于人脸识别的。所以有必要将人脸图像都变换到一个统一的角度和姿态，这就是人脸对齐。它的原理是找到人脸的若干个关键点（基准点，如眼角，鼻尖，嘴角等），然后利用这些对应的关键点通过相似变换（Similarity Transform，旋转、缩放和平移）将人脸尽可能变换到标准人脸。 人脸特征表征 第三个模块是本文重点要讲的人脸识别算法，它接受的输入是标准化的人脸图像，通过特征建模得到向量化的人脸特征，最后通过分类器判别得到识别的结果。这里的关键是怎样得到对不同人脸有区分度的特征，通常我们在识别一个人时会看它的眉形、脸轮廓、鼻子形状、眼睛的类型等，人脸识别算法引擎要通过练习（训练）得到类似这样的有区分度的特征。本系列文章主要围绕人脸识别中的人脸特征表征进行展开，人脸检测和人脸对齐方法会在其它专题系列文章中进行介绍。 人脸识别算法的三个阶段人脸识别算法经历了早期算法，人工特征+分类器，深度学习3个阶段。目前深度学习算法是主流，极大的提高了人脸识别的精度。 早期算法 早期的算法有基于几何特征的算法，基于模板匹配的算法，子空间算法等多种类型。子空间算法将人脸图像当成一个高维的向量，将向量投影到低维空间中，投影之后得到的低维向量达到对不同的人具有良好的区分度。 子空间算法的典型代表是PCA（主成分分析，也称为特征脸EigenFace）[1]和LDA（线性判别分析，FisherFace）[2]。PCA的核心思想是在进行投影之后尽量多的保留原始数据的主要信息，降低数据的冗余信息，以利于后续的识别。LDA的核心思想是最大化类间差异，最小化类内差异，即保证同一个人的不同人脸图像在投影之后聚集在一起，不同人的人脸图像在投影之后被用一个大的间距分开。PCA和LDA最后都归结于求解矩阵的特征值和特征向量，这有成熟的数值算法可以实现。 PCA和LDA都是线性降维技术，但人脸在高维空间中的分布显然是非线性的，因此可以使用非线性降维算法，典型的代表是流形学习[3]和核（kernel）技术。流形学习假设向量点在高维空间中的分布具有某些几何形状，然后在保持这些几何形状约束的前提下将向量投影到低维空间中，这种投影是通过非线性变换完成的。 人工特征 + 分类器 第二阶段的人脸识别算法普遍采用了人工特征 + 分类器的思路。分类器有成熟的方案，如神经网络，支持向量机[7]，贝叶斯[8]等。这里的关键是人工特征的设计，它要能有效的区分不同的人。 描述图像的很多特征都先后被用于人脸识别问题，包括HOG、SIFT、Gabor、LBP等。它们中的典型代表是LBP（局部二值模式）特征[9]，这种特征简单却有效。LBP特征计算起来非常简单，部分解决了光照敏感问题，但还是存在姿态和表情的问题。 联合贝叶斯是对贝叶斯人脸的改进方法[8]，选用LBP和LE作为基础特征，将人脸图像的差异表示为相同人因姿态、表情等导致的差异以及不同人间的差异两个因素，用潜在变量组成的协方差，建立两张人脸的关联。文章的创新点在于将两个人脸表示进行联合建模，在人脸联合建模的时候，又使用了人脸的先验知识，将两张人脸的建模问题变为单张人脸图片的统计计算，更好的验证人脸的相关性，该方法在LFW上取得了92.4%的准确率。 人工特征的巅峰之作是出自CVPR 2013年MSRA的”Blessing of Dimisionality: High Dimensional Feature and Its Efficient Compression for Face Verification” [10]，一篇关于如何使用高维度特征在人脸验证中的文章，作者主要以LBP（Local Binary Pattern，局部二值特征）为例子，论述了高维特征和验证性能存在着正相关的关系，即人脸维度越高，验证的准确度就越高。 深度学习 第三个阶段是基于深度学习的方法，自2012年深度学习在ILSVRC-2012大放异彩后，很多研究者都在尝试将其应用在自己的方向，这极大的推动了深度学习的发展。卷积神经网络在图像分类中显示出了巨大的威力，通过学习得到的卷积核明显优于人工设计的特征+分类器的方案。在人脸识别的研究者利用卷积神经网络（CNN）对海量的人脸图片进行学习，然后对输入图像提取出对区分不同人的脸有用的特征向量，替代人工设计的特征。 在前期，研究人员在网络结构、输入数据的设计等方面尝试了各种方案，然后送入卷积神经网络进行经典的目标分类模型训练；在后期，主要的改进集中在损失函数上，即迫使卷积网络学习得到对分辨不同的人更有效的特征，这时候人脸识别领域彻底被深度学习改造了！ DeepFace[11]是CVPR2014上由Facebook提出的方法，是深度卷积神经网络在人脸识别领域的奠基之作，文中使用了3D模型来做人脸对齐任务，深度卷积神经网络针对对齐后的人脸Patch进行多类的分类学习，使用的是经典的交叉熵损失函数（Softmax）进行问题优化，最后通过特征嵌入（Feature Embedding）得到固定长度的人脸特征向量。Backbone网络使用了多层局部卷积结构（Local Convolution），原因是希望网络的不同卷积核能学习人脸不同区域的特征，但会导致参数量增大，要求数据量很大，回过头去看该策略并不是十分必要。 DeepFace在LFW上取得了97.35%的准确率，已经接近了人类的水平。之后Google推出FaceNet（Facenet论文地址），使用三元组损失函数(Triplet Loss)代替常用的Softmax交叉熵损失函数，在一个超球空间上进行优化使类内距离更紧凑，类间距离更远，最后得到了一个紧凑的128维人脸特征，其网络使用GoogLeNet的Inception模型，模型参数量较小，精度更高，在LFW上取得了99.63%的准确率，这种损失函数的思想也可以追溯到早期的LDA算法。 CVPR2014、CVPR2015香港中文大学汤晓鸥团队提出的DeepID系列是一组非常有代表性的工作，其中DeepID1[12]使用四层卷积，最后一层为Softmax，中间为Deep Hidden Identity Features，是学习到的人脸特征表示，并使用Multi-patch分别训练模型最后组合成高维特征，人脸验证阶段使用联合贝叶斯的方法；通过学习一个多类（10000类，每个类大约有20个实例）人脸识别任务来学习特征，文中指出，随着训练时要预测的人脸类越多，DeepID的泛化能力就越强。 人脸识别算法仓库 ageitgey/face_recognition: https://github.com/ageitgey/face_recognition davidsandberg/facenet: https://github.com/davidsandberg/facenet cmusatyalab/openface: https://github.com/cmusatyalab/openface kpzhang93/MTCNN_face_detection_alignment(人脸检测): https://github.com/kpzhang93/MTCNN_face_detection_alignment deepinsight/insightface: https://github.com/deepinsight/insightface nyoki-mtl/keras-facenet: https://github.com/nyoki-mtl/keras-facenet yuyang-huang/keras-inception-resnet-v2(网络结构): https://github.com/yuyang-huang/keras-inception-resnet-v2 相关博客 应用一个基于Python的开源人脸识别库，face_recognition:https://blog.csdn.net/hongbin_xu/article/details/76284134 TensorFlow–实现人脸识别实验精讲 （Face Recognition using Tensorflow）:https://blog.csdn.net/niutianzhuang/article/details/79191167 基于卷积神经网络和tensorflow实现的人脸识别:https://blog.csdn.net/hy13684802853/article/details/79780805 keras/构建卷积神经网络人脸识别: https://blog.csdn.net/szj_huhu/article/details/75202254 人脸识别–(opencv、dlib、keras-TensorFlow）:https://blog.csdn.net/u014258362/article/details/80688224 TensorFlow实现人脸识别(5)——-利用训练好的模型实时进行人脸检测:https://blog.csdn.net/yunge812/article/details/79447584 基于keras的人脸识别:https://blog.csdn.net/Julymycin/article/details/79182222 史上最全的FaceNet源码使用方法和讲解（一）（附预训练模型下载）:https://blog.csdn.net/u013044310/article/details/79556099https://github.com/boyliwensheng/understand_facenet(作者整理代码)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs与Django的跨域问题]]></title>
    <url>%2F2018%2F07%2F08%2FNodejs%E4%B8%8EDjango%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Nodejs与Django的跨域问题由于采用前后端分离的编程方式，Django的csrf_token验证失效，出现跨域问题，在此记录一下解决方法。 1 安装django-cors-headers pip install django-cors-headers 2 配置settings.py文件 OK！问题解决！]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django使用MongoDB数据库]]></title>
    <url>%2F2018%2F07%2F08%2FDjango%E4%BD%BF%E7%94%A8MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[之前学习使用Django搭建在线教育平台使用的是Mysql数据库，现在考虑到公司以后的发展及当前技术需求，更换为MongoDB数据库。在此记录一下更改操作： 1 首先安装mongoengine，并在setting中设置对应的位置 pip instal mongoengine 2 设置默认的数据库信息 3 设置Model 总结之前因为使用Django自带的admin后台管理系统，所以在像Mysql一样迁移数据库时出现错误。后来分析发现，目前使用Django所做的工作不需要用到后台管理系统，仅仅是作为一个后台服务，因此可直接运行。至此，设置完成。]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS7为firewalld添加开放端口及相关操作]]></title>
    <url>%2F2018%2F07%2F05%2FCentOS7%E4%B8%BAfirewalld%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[firewalld的基本使用启动： systemctl start firewalld 查看状态： systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctlstop firewalld.service 重启一个服务：systemctlrestart firewalld.service 显示一个服务的状态：systemctlstatus firewalld.service 在开机时启用一个服务：systemctlenable firewalld.service 在开机时禁用一个服务：systemctldisable firewalld.service 查看服务是否开机启动：systemctlis-enabled firewalld.service 查看已启动的服务列表：systemctllist-unit-files|grep enabled 查看启动失败的服务列表：systemctl--failed 配置firewalld-cmd查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd--zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd--get-active-zones 查看指定接口所属区域： firewall-cmd--get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入firewall-cmd --reload 查看firewall-cmd --zone=public --query-port=80/tcp 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看firewall是否运行,下面两个命令都可以systemctl status firewalld.service firewall-cmd --state 查看当前开了哪些端口其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。 firewall-cmd --list-services 查看还有哪些服务可以打开firewall-cmd --get-services 查看所有打开的端口：firewall-cmd --zone=public --list-ports 更新防火墙规则：firewall-cmd --reload]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs与Django图片信息传输]]></title>
    <url>%2F2018%2F07%2F05%2FNodejs%E4%B8%8EDjango%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[Nodejs与Django图片信息传输由于公司需要Nodejs的前端与Django的后端进行交互，其中涉及到图片信息作为二进制流传输，在此记录前后端分离中二进制图片在Django中的保存与转换。 Nodejs中的数据传输Nodejs采用Input插件读取图片 其中涉及到公司大牛写的Webship框架，但传送数据的方式没有大的改变 Django保存传输的二进制图片首先，我们分析request请求中所包含的信息： 通过分析，发现request中FILES属性是前端发给我们的包含图片信息的内容，我们取出FILES属性中的内容赋值给files，再进行分析，看我们需要的图片究竟是什么样的内容和格式，内容如下： 可以发现，files变量中包含name属性，即我提交的图片名字，还有一个file属性，其是一个bytes格式的变量入口，这个可能就是我需要的二进制图片，经过测试，读取这个file属性得到的二进制流和我以‘rb’模式read()提交的同一个图片所得到的二进制流相等。至此，就找到了requst中所包含的图片信息，然后将其保存到指定路径中： 完成！]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django文档——Model字段类型]]></title>
    <url>%2F2018%2F06%2F14%2FDjango%E6%96%87%E6%A1%A3%E2%80%94%E2%80%94Model%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字段类型(Field types)AutoField它是一个根据 ID 自增长的 IntegerField 字段。通常，你不必直接使用该字段。如果你没在别的字段上指定主 键，Django 就会自动添加主键字段。 BigIntegerField64位整数，类似于IntegerField，范围从-9223372036854775808 到9223372036854775807。默认的form widget 是TextInput。 BooleanField一个布尔值(true/false)字段。 默认的form widget是CheckboxInput。 如果要使用null作为空值，可使用NullBooleanField。 CharFieldclass CharField(max_length=None[, **options]) 它是一个字符串字段，对小字符串和大字符串都适用。 对于更大的文本，应该使用TextField 。 默认的form widget是TextInput。 CharField 有一个必须传入的参数：max_length,字段的最大字符数。它作用于数据库层级和 Django 的数据验证层级。 CommaSeparatedInterFieldclass CommaSeparatedIntegerField(max_length=None[, **options]) 它用来存放以逗号间隔的整数序列。和 CharField 一样，必须为它提供 max_length 参数。而且要注意不同数据库对 max_length 的限制。 DateFieldclass DateField([auto_now=False, auto_now_add=False, **options]) 该字段利用 Python 的 datetime.date 实例来表示日期。下面是它额外的可选参数： DateField.auto_now：每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示 “最后修改” 时间。要注意使用的是当前日期，而并非默认值，所以 不能通过重写默认值的办法来改变保存时间。 DateField.auto_now_add：在第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。它使用的同样是当前日期，而非默认值。 默认的form widget是TextInput。 Note:当auto_now或者auto_now_add设置为True时，字段会有editable=True和blank=True的设定。 DateTimeFieldclass DateTimeField([auto_now=False, auto_now_add=False, **options]) 该字段利用 datetime.datetime 实例表示日期和时间。该字段所按受的参数和 DateField 一样。 默认的form widget是TextInput。Django 的admin使用两个带有 JavaScript 快捷选项TextInput分别表示日期和时间。 DecimalFieldclass DecimalField(max_digits=None, decimal_places=None[, **options]) 它是使用 Decimal 实例表示固定精度的十进制数的字段。它有两个必须的参数： DecimalField.max_digits：数字允许的最大位数 DecimalField.decimal_places：小数的最大位数 例如，要存储的数字最大值是999，而带有两个小数位，你可以使用： 1models.DecimalField(…, max_digits=5, decimal_places=2)要存储大约是十亿级且带有10个小数位的数字，就这样写： 1models.DecimalField(…, max_digits=19, decimal_places=10)默认的form widget是TextInput。 EmailFieldclass EmailField([max_length=75, **options]) 它是带有 email 合法性检测的A CharField 。 Note：最大长度默认为75，并不能存储所有与RFC3696/5321兼容的email地址。如果要存储所有，请设置 max_length=254。设置为75是历史遗留问题。 FileFieldclass FileField(upload_to=None[, max_length=100, **options]) 文件上传字段 Note：该字段不支持 primary_key 和 unique 参数，否则会抛出 TypeError 异常。 它有一个必须的参数： FileField.upload_to 用于保存文件的本地文件系统。它根据 MEDIA_ROOT 设置确定该文件的 url 属性。 该路径可以包含 时间格式串strftime()，可以在上传文件的时候替换成当时日期／时间(这样，就不会出现在上传文件把某个目录塞满的情况了)。 该参数也可以是一个可调用项，比如是一个函数，可以调用函数获得包含文件名的上传路径。这个可调用项必须要接受两个参数， 并且返回一个保存文件用的 Unix-Style 的路径(用 / 斜杠)。两个参数分别是： instance ：定义了当前 FileField 的 model 实例。更准确地说，就是以该文件为附件的 model 实例。 大多数情况下，在保存该文件时， model 实例对象还并没有保存到数据库，这是因为它很有可能使用默认的 AutoField，而此时它还没有从数据库中获得主键值。 filename ：上传文件的原始名称。在生成最终路径的时候，有可能会用到它。 还有一个可选的参数： FileField.storage 负责保存和获取文件的对象。 默认的form widget是FileInput。 Note：在 model 中使用 FileField 或 ImageField 要按照以下的步骤： 1.在项目settings文件中，你要定义 MEDIA_ROOT ，将它的值设为用来存放上传文件的目录的完整路径。(基于性能的考虑，Django 没有将文件保存在数据库中). 然后定义 MEDIA_URL ，将它的值设为表示该目录的网址。 要确保 web 服务器所用的帐号拥有对该目录的写权限。 2.在 model 里面添加 FileField 或 ImageField ，并且确认已定义了 upload_to 项，让 Django 知道应该用 MEDIA_ROOT 的哪个子目录来保存文件。 3.存储在数据库当中的仅仅只是文件的路径(而且是相对于 MEDIA_ROOT 的相对路径)。你可能已经想到利用 Django 提供的 url 这个方便的属性。举个例子，如果你的 ImageField 名称是 mug_shot，那么你可以在模板 中使用 1就能得到图片的完整网址。 例如，假设你的 MEDIA_ROOT 被设为 ‘/home/media’，upload_to 被设为 ‘photos/%Y/%m/%d’。 upload_to 中 的 ‘%Y/%m/%d’ 是一个strftime()， ‘%Y’ 是四位的年份，’%m’ 是两位的月份， ‘%d’ 是两位的日子。如果你 在2007年01月15号上传了一个文件，那么这个文件就保存在 /home/media/photos/2007/01/15 目录下。 如果你想得到上传文件的本地文件名称，文件网址，或是文件的大小，你可以使用 name, url 和 size 属性。 Note：在上传文件时，要警惕保存文件的位置和文件的类型，这么做的原因是为了避免安全漏洞。对每一个上传 文件都要验证，这样你才能确保上传的文件是你想要的文件。举个例子，如果你盲目地让别人上传文件，而没有 对上传文件进行验证，如果保存文件的目录处于 web 服务器的根目录下，万一有人上传了一个 CGI 或是 PHP 脚本，然后通过访问脚本网址来运行上传的脚本，那可就太危险了。千万不要让这样的事情发生！ 默认情况下，FileField 实例在数据库中的对应列是 varchar(100) ，和其他字段一样，你可以利用max_length 参数改变字段的最大长度。 FileField and FieldFile class FieldFile 当你访问一个Model的FileField字段时，会得到一个FieldFile的实例作为代理去访问底层文件。实例有几种属性和方法可以用来和文件数据进行互动。 FieldFile.url 通过只读的方式调用底层存储(Storage)类的 url() 方法，来访问该文件的相对URL。 FieldFile.open(mode=’rb’) 类似于python的open()方法。 FieldFile.close() 类似于python的close()方法。 FieldFile.save(name,content,save=True) 这种方法将filename和文件内容传递到该字段然后存储到该模型。该方法需要两个必须的参数：name， 文件的名称， content， 包含文件内容的对象。save 参数是可选的，主 要是控制文件修改后实例是否保存。默认是 True 。需要注意的是，content 参数是 django.core.files.File 的一个实例，不是Python的内置File对象。你可以使 用他从现有的Python文件对象中构建一个文件，如下所示： 1234from django.core.files import File Open an existing file using Python’s built-in open()f = open(‘/tmp/hello.world’)myfile = File(f)或者从字符串中构造： 12from django.core.files.base import ContentFilemyfile = ContentFile(“hello world”)FieldFile.delete(save=True) 删除此实例相关的文件，并清除该字段的所有属性。 Note：当delete()被调用时，如果文件正好是打开的，该方法将关闭文件。 save 参数是可选的，控制文件删除后实例是否保存。默认是 True 。 需要注意的是，当一个模型被删除时，相关文件不被删除。如果想删除这些孤立的文件，需要自己去处理（比如，可以手动运行命令清理，也可以通过cron来定期执行清理命令） FilePathFieldclass FilePathField(path=None[, match=None, recursive=False, max_length=100, **options]) 它是一个 CharField ，它用来选择文件系统下某个目录里面的某些文件。它有三个专有的参数，只有第一个参 数是必须的： FilePathField.path 这个参数是必需的。它是一个目录的绝对路径，而这个目录就是 FilePathField 用来选择文件的那个目录。比 如： “/home/images”. FilePathField.match 可选参数。它是一个正则表达式字符串， FilePathField 用它来过滤文件名称，只有符合条件的文件才出现在 文件选择列表中。要注意正则表达式只匹配文件名，而不是匹配文件路径。例如：”foo.*.txt$” 只匹配名为 foo23.txt 而不匹配 bar.txt 和 foo23.gif。 FilePathField.recursive 可选参数。它的值是 True 或 False。默认值是 False。它指定是否包含 path 下的子目录。 FilePathField.allow_files 该项属于Django1.5新增内容。可选参数，它的值是 True 或 False。默认值是 True。它指定是否包含指定位置的文件。该项与allow_folders 必须有一个是 True。 FilePathField.allow_folders Django1.5新增内容。可选参数，它的值是True或False。默认是False。它指定是否包含指定位置的目录。该项与allow_files必须有一个是 True。 前面已经提到了 match 只匹配文件名称，而不是文件路径。所以下面这个例子： 1FilePathField(path=”/home/images”, match=”foo.*”, recursive=True)将匹配 /home/images/foo.gif ，而不匹配 /home/images/foo/bar.gif。这是因为 match 只匹配文件名(foo.gif 和 bar.gif). 默认情况下， FilePathField 实例在数据库中的对应列是varchar(100) 。和其他字段一样，你可以利用 max_length 参数改变字段的最大长度。 FloatFieldclass FloatField([**options]) 该字段在 Python 中使用float 实例来表示一个浮点数。 默认的form widget是TextInput。 请注意FloatField与DecimalField的区别。 ImageFieldclass ImageField(upload_to=None[, height_field=None, width_field=None, max_length=100,**options]) 和 FileField 一样，只是会验证上传对象是不是一个合法的图象文件。 除了那些在 FileField 中有效的参数之外， ImageField 还可以使用 File.height and File.width 两个属性 。 它有两个可选参数： ImageField.height_field 保存图片高度的字段名称。在保存对象时，会根据该字段设定的高度，对图片文件进行缩放转换。 ImageField.width_field 保存图片宽度的字段名称。在保存对象时，会根据该字段设定的宽度，对图片文件进行缩放转换。 默认情况下， ImageField 实例对应着数据库中的varchar(100) 列。和其他字段一样，你可以使 用 max_length 参数来改变字段的最大长度。 IntegerFieldclass IntegerField([**options]) 整数字段。默认的form widget是TextInput。 IPAddressFieldclass IPAddressField([**options]) 以字符串形式(比如 “192.0.2.30”)表示 IP 地址字段。默认的form widget是TextInput。 GenericIPAddressFieldclass GenericIPAddressField([**options]) Django1.4新增。 以字符串形式(比如 “192.0.2.30”或者”2a02:42fe::4”)表示 IP4或者IP6 地址字段。默认的form widget是TextInput。 IPv6的地址格式遵循RFC 4291 section 2.2。比如如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示，例如 “::ffff:192.0.2.0”。 2001:0::0:01可以写成2001::1,而::ffff:0a0a:0a0a可以写成::ffff:10.10.10.10。字母都为小写。 GenericIPAddressField.protocol 验证输入协议的有效性。默认值是 ‘both’ 也就是IPv4或者IPv6。该项不区分大小写。 GenericIPAddressField.unpack_ipv4 解释IPv4映射的地址，像 ::ffff:192.0.2.1 。如果启用该选项，该地址将必解释为 192.0.2.1 。默认是禁止的。只有当 protocol 被设置为 ‘both’ 时才可以启用。 NullBooleanFieldclass NullBooleanField([**options]) 与 BooleanField 相似，但多了一个 NULL 选项。建议用该字段代替使用 null=True 选项的 BooleanField 。 默认的form widget是NullBooleanSelect。 PositiveIntegerFieldclass PositiveIntegerField([**options]) 和 IntegerField 相似，但字段值必须是非负数。 PositiveSmallIntegerFieldclass PositiveSmallIntegerField([**options]) 和 PositiveIntegerField 类似，但数值的取值范围较小，受限于数据库设置。 SlugFieldclass SlugField([max_length=50, **options]) Slug 是一个新闻术语，是指某个事件的短标签。它只能由字母，数字，下划线或连字符组成。通赏情况下，它被用做网址的一部分。 和 CharField 类似，你可以指定 max_length (要注意数据库兼容性和本节提到的 max_length )。如果没有指定 max_length ，Django 会默认字段长度为50。 该字段会自动设置 Field.db_index to True。 基于其他字段的值来自动填充 Slug 字段是很有用的。你可以在 Django 的管理后台中使用prepopulated_fields 来做到这一点。 SmallIntegerFieldclass SmallIntegerField([**options]) 和 IntegerField 类似，但数值的取值范围较小，受限于数据库的限制。 TextFieldclass TextField([**options]) 大文本字段。默认的form widget是Textarea。 TimeFieldclass TimeField([auto_now=False, auto_now_add=False, **options]) 该字段使用 Python 的 datetime.time 实例来表示时间。它和 DateField 接受同样的自动填充的参数。 默认的form widget是TextInput。 URLFieldclass URLField([max_length=200, **options]) 保存 URL 的 CharField 。 和所有 CharField 子类一样，URLField 接受可选的 max_length 参数，该参数默认值是200。]]></content>
  </entry>
  <entry>
    <title><![CDATA[点滴积累]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%82%B9%E6%BB%B4%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[hexo生成博文插入图片 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ! [你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 Error: That port is already in use.的错误。即端口号已经被占用,说明servr已经在运行了(也有可能在后台运行) 那么找到该进程,kill掉即可. 或者最简单的解决方法就是： 在终端输入 sudo fuser -k 8000/tcp 这样和端口8000相关的进程就都关了。 Centos下实现word转pdflibreoffice –headless –invisible –convert-to pdf 模版123.docx –outdir /filepath 爆破大数据平台Nodejs后端 1 创建数据库 1 使用redis、mongodb 2 使用Mysql 其中有DATATIME属性 2 使用Admzip以及正则表达式实现文档的替换 3 将生成的文档转换为PDF Django后端 1 设计Model 2 前后端分离传递数据 3 算法的嵌入 涉及算法 1 图像识别 2 自动布孔]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>日常记录</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——EM算法]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[EM算法EM简介EM(Expectation Mmaximization) 是一种迭代算法， 用于含隐变量(Latent Variable) 的概率模型参数的极大似然估计， 或极大后验概率估计 EM算法由两步组成， 求期望的E步，和求极大的M步。EM算法可以看成是特殊情况下计算极大似然的一种算法。现实的数据经常有一些比较奇怪的问题，比如缺失数据、含有隐变量等问题。当这些问题出现的时候，计算极大似然函数通常是比较困难的，而EM算法可以解决这个问题。 EM算法已经有很多应用，比如最经典的Hidden Markov模型等。经济学中，除了逐渐开始受到重视的HMM模型（例如Yin and Zhao, 2015），其他领域也有可能涉及到EM算法，比如在Train的《Discrete Choice Methods with Simulation》就给出了一个 $mixed logit$ 模型的EM算法。 EM算法的预备知识 极大似然估计 1 举例说明：经典问题——学生身高问题 我们需要调查我们学校的男生和女生的身高分布。 假设你在校园里随便找了100个男生和100个女生。他们共200个人。将他们按照性别划分为两组，然后先统计抽样得到的100个男生的身高。假设他们的身高是服从高斯分布的。但是这个分布的均值u和方差∂2我们不知道，这两个参数就是我们要估计的。记作θ=[u, ∂]T。问题：我们知道样本所服从的概率分布的模型和一些样本，而不知道该模型中的参数。我们已知的有两个：（1）样本服从的分布模型（2）随机抽取的样本 需要通过极大似然估计求出的包括：模型的参数总的来说：极大似然估计就是用来估计模型参数的统计学方法。 2 如何估计 问题数学化： (1)样本集: x={$x_1,x_2,…,x_N$}, $N=100$。 (2)概率密度：$p(x_i|\theta)$ 抽到男生$i$（的身高）的概率 100个样本之间独立同分布，所以我同时抽到这100个男生的概率就是他们各自概率的乘积。就是从分布是$p(x|\theta)$ 的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$这个概率反映了，在概率密度函数的参数是$\theta$时，得到X这组样本的概率。 需要找到一个参数θ，其对应的似然函数$L(\theta)$最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做$\theta$的最大似然估计量，记为$$argmaxL(\theta)$$ 3 求最大似然函数估计值的一般步骤 首先，写出似然函数：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$其次，对似然函数取对数，并整理：$$H(\theta)=lnL(\theta)=ln\prod_{i=1}^n{p(x_i|\theta)}=\sum_{i=1}^n{lnp(x_i|\theta)}$$然后，求导数，令导数为0，得到似然方程；最后，解似然方程，得到的参数即为所求。 4 总结 多数情况下我们是根据已知条件来推算结果，而极大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS环境搭建]]></title>
    <url>%2F2018%2F06%2F05%2FCentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[系统安装电脑配置 微星1080Ti 至强E5 -2620v4 技嘉的主板 踩坑记录将CentOS 7.4镜像刻到U盘之后，向服务器安装时，使用U盘启动会出现两种启动选项，一种是UEFI启动选项，一种是默认的启动选项，如果不使用UEFI方式安装，那么一般是没有问题的，如果选择UEFI方式安装系统，那么引导系统时会出现如下的提示： [sdb] No Caching mode page found [sdb] Assuming drive cache:write through Could not boot /dev/root does not exist 然后命令行就卡在这了，现在只需要耐心等待，等一会之后会不断的滚动错误警告，这个时候继续等待，那么一会就会出来命令行输入界面，这个时候输入以下命令： ls /dev/sd* 输入命令之后会列出所有的存储设备，这个时候一般情况下第一块硬盘是sda，如果有多个分区，那么依次就是sda1、sda2等等，如果有两块硬盘那么就是sdb，U盘一般是排最后的号，如果有一块硬盘，那么U盘就是sdb，如果有两块硬盘，那么U盘就是sdc，U盘一般会有sdc和sdc4两个选项，sdc属于U盘存储，sdc4就是镜像所在分区了，这样一般是没有问题的，如果出现问题，那么接下来多配置几次就好了，接下来输入命令reboot重启计算机，在安装界面，先不要选择安装，这个时候按一下e键，会进入编辑界面，移动光标进行如下修改： 在第二行默认是：vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 把这行修改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4:/ quiet 就是把hd:和quiet之间的内容修改为U盘镜像所在位置这样就可以了，注意要写成/dev/sdc4:/ 然后根据提示按Ctrl+X键就可以开始安装了，现在就正常进入安装界面了 NVIDIA驱动安装1、在官网上http://www.geforce.cn/drivers搜索到对应型号的显卡驱动并下载，下载到的驱动文件是一个后缀名为.run的文件（例如NVIDIA-Linux-x86_64-384.98.run）； 2、安装gcc编译环境以及内核相关的包： yum install kernel-devel kernel-doc kernel-headers gcc* glibc* glibc-*注意：安装内核包时需要先检查一下当前内核版本是否与所要安装的kernel-devel/kernel-doc/kernel-headers的版本一致，请务必保持两者版本一致，否则后续的编译过程会出问题。 3、禁用系统默认安装的 nouveau 驱动，修改/etc/modprobe.d/blacklist.conf 文件： 修改配置echo -e &quot;blacklist nouveau\noptions nouveau modeset=0&quot; &gt; /etc/modprobe.d/blacklist.conf 备份原来的镜像文件mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak 重建新镜像文件dracut /boot/initramfs-$(uname -r).img $(uname -r) 重启reboot 在命令行界面init 5 查看nouveau是否启动，如果结果为空即为禁用成功lsmod | grep nouveau 4、安装DKMS模块 DKMS全称是DynamicKernel ModuleSupport，它可以帮我们维护内核外的驱动程序，在内核版本变动之后可以自动重新生成新的模块。 sudo yum install DKMS 5、执行显卡驱动安装脚本（如果内核版本一致，就不需要指定–kernel-source-path和-k） ./NVIDIA-Linux-x86_64-384.98.run --kernel-source-path=/usr/src/kernels/3.10.0-693.11.1.el7.x86_64/ -k $(uname -r) --dkms -s 6、若步骤5执行过程中没报错，则安装成功。重启，执行nvidia-smi可查看相关信息。如若出现重启系统驱动找不到的情况，在装完驱动后，切记，先不要重启，使用 init5 和 init 3 交替切换，几次后，会进入图形界面（其中init 5为进入图形界面的命令），之后，在图形界面，重新编译一下启动项。 CUDA&amp;&amp;CUDNN 关于cuda和cudnn的安装，这一点尤其要注意。我在CentOS7.5(更新后的版本，初始装的时候为7.4)上安装CUDA9.2时，无法与NVIDIA的驱动匹配，因此退而求其次，选择了CUDA9.1，同时CUDNN选择7.0.5版本。注意 不要下载cudnn-9.1-linux-ppc64le-v7.1.tgz，因为ppc64le并不是针对X64的电脑系统CUDA的安装我选择了使用yum安装的方式，因为之前使用命令行，出现了未知的错误，导致系统重装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习的东西]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX186vUkxn9x2qwEwaMmdFBUU6Bu6usoc2B8WtnVw8nMjtdtirURxMcDdjXlvikl/xGm4XBv+PAT0kN+x4SLXSRry3B9ALnz0JfVlrLbOtw0bE5atHIMGyZFYTGUgTia9B4CXSwtyPcyOz/XiFFrrTI6SCBfGcNJvfrWzb6BtJZAMND/R4gyEN2o28A1gnMaQh/qTR/W4ssX95WL2qbbP+arHADrgAskeT2DGmigWUC7du4Ytl8zhaiFXPkFpS1CYVt0qjSa7K17XNVkSR++aACGXUT7Gab9RlXKbaSTc/NwgQmN4he4+8256FOFn2UvHwGjf5Jas/HJomTxG1n/EMYTP3Sn5mdr6XmjWEsn2RTQl/J0gmG9G0zqkOznytRX0L6UXCapsXHlSfHeQdjqNmeARkpGlD/xlRKhHAGApqMp8VWhnp/H6lV5LeNHs3VJw30bifG2kLRhtVrB+TVeDaoWDaV2qVaewlAPdc1Y37chysdUcR2vv2+g5Oi4vh+0yw4HUiigtNWGejSCPDBd98m47jt7xuJRv67pVOJeza4+HVxzvvYW4RwOIE9ZXHEypmiB1PSBpG7BNFNQSlAuB5jyJrsk9xGwdPzybc43by28/h8u3Jd4CdoMyaaBi9cKCHG7U4QF+8t471+6oIlIIxf50rVsCiv49RDja/8VS94dTQ1cTD68fC9ZtDGM84QMn1x9NEpAvaCF06LNqhbW7Kwo0nxmAc4pb8phOFxZFvPZPSobnrUnLKUTAOyR0bC+rOhTXr5x4KXMYzOwBGct8MkYD/KQOT7mRs9pFIShJfPWWEBwlRb6A9loYR1XVKft9ngGxQXUrXvSoWCgcDWwB9HCH3LibYD5PqUjKDhYIPyzTy75Cr1CC3pCO4s7nIXItBZvZy9lMGB2BonogxHydFNNoZn0YEtJa9HbzNtEEco8+E4L2hXi+DRVUra+MWUF8kAA0nN5GkeUPgUZCJIixI5648whnYF1/ZdIy3KzMBIAb8XN9IRB4OoU0xUIslpDcEN+aK28lCDeGrs56cDBQO42k6KKLorgiUBCmXpWA/6bWZyheZ1RtE5AzJax8BF11YS+RkY8Vcp9s8W4k5F1fObJxyckCqimJ9stnVUNl+/MfO2cuHISJSQmbCH/vRZizN6EM4eT+o90rbzVS3bFrlPHNzUQzSC2XKSJ5Va6dMKe9zjbodUxuDIqV7m4pZ1FvpWW0pvJcoSRNKgRLV+VZ5DFl/Bqdyw3qPxgQPKWpj35YkLZB4cffcrgT2Xh2EXb8L/aJUmZdnp/fLItE8dNfSLluxQ7Skt5flMC0qrqEYumg/seDYp2f5r1is+u3W5Fp+eJhc6PIYZ7Ulu9/diD7f5zorV1fq3vxnlT5cmIVyjzZWNqI6lk9T/O8Z7r9UGsbEVSmyMOqluoGdQLI3vpDUUFvgbcPm8pruJnPwzEAGTmGK+uJRonlnC/ozOGtsrOFPukv/MXUXbpwb2KPtF5DAFnC/vfzcNGwlD23jlSLNzeA3rrOPXrRCFfhiowCvUMsYiwmsPMiT9H/ouJz+2iSXMc/pWEFEJF4LaLrUNC/g6CIuH+Eiymmy2ryWRUgLx8lcEltS/B02e7kGQvQ8NSj3CcTqbZQc/TrBJUY2p+cUqglE2WX/kx/drpBXK9qWNOASZWTq8qJHZr+d2sj0DEVoSS1i0HRAs4E0P6YzK80tcC28sXNAnc1sAQ67jE5KQdwMTEt0jh3m/a4OSyzjyDhjLk3P0bAZ09gF+3pDZvJq1oT3Oytu/99l5fB981S8qFi87vH0PVRqjdWyJXbXTJ0cbT1bM9j7SAX9ndv5G2Z+Fyx22CaazM9CsmoNAflmTp023kVj9zT6K0ucziu48+mfdf9WXHn4wrpvFY= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>自省</category>
      </categories>
      <tags>
        <tag>坚持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的网站逻辑]]></title>
    <url>%2F2018%2F05%2F29%2FDjango%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Django实战——后台逻辑Django用户 （登录 注册 找回密码）登录 后台的操作放在对应app的views文件下，当我们在路由中添加一个url，django会自动为我们生成一个request，并添加到函数里面。首先判断请求方法，是POST还是GET。然后跳转到对应的页面进行操作。 对登录账户进行验证（采用类来做） 得到用户名和密码后，使用django.contrib.auth.authenticate进行验证，验证成功的话得到一个对象，然后进行对应后台逻辑的编写，即调用django.contrib.auth.login进行验证。 对登录成功后返回index.html文件的状态处理，需要在html文件中进行判断，用户是否登录，调用request.user.user.is_authenticated来进行判断。决定显示哪一行代码。 自定义认证方法，实现邮箱的登录方式（重定义方式） Seesion和Cookie机制 无状态请求 有状态请求 注册 准备工具 添加插件（captcha） 提交注册信息（包括注册码）发送邮件验证注册信息激活账户 找回密码 采用类似于激活账户的方式来实现]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adm-zip工具]]></title>
    <url>%2F2018%2F05%2F29%2FAdm-zip%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Adm-zip介绍 Adm-zip是JavaScript中的一款与压缩文件相关的插件，其功能相当的强大（我看来），我用其实现了对Word文档的内容替换。 Word 文档本质上是一个压缩 文件夹，其中的word文件夹下的document.xml文件是包含文档内容的文件，而我们需要操作的也正是这个文件。 Adm-zip这款插件则正好满足我们即对压缩文件内部条目文件的处理，同时又保证不影响压缩文件内部其余文件的要求。 我们需要的函数接口主要有四个，分别为： 读取压缩文件内指定目录里面的文件或者文件夹： Admzip.readAsText() 删除压缩文件内的指定文件或者文件夹： Admzip.deleteFile() 将指定文件写入到压缩文件夹中： Admzip.addFile() 将所做的更改重新写入文件（可以是当前文件，也可以重命名的word文档） Admzip.writeZip() 关于Adm-zip的使用方法，暂时只发现了这样一种，其还有别的Api接口，有兴趣的小伙伴可以自己再研究下^_^]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Adm-zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MARKDOWN语法熟悉]]></title>
    <url>%2F2018%2F05%2F28%2FMARKDOWN%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[基础标题测试一级标题二级标题三级标题四级标题五级标题六级标题换行和分段未换行未换行测试示例 换行后已换行测试（后有两个空格）示例 分段分段测试 分段 文本样式加粗(使用两个*号)斜体（使用一个号）*删除线(使用两个波浪线)‘底纹（单引号）’ 列表在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。 无序列表： 在文本前加 「 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）在 「 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。 无序列表 1 2 2.1 2.1.1 2.1.1.1 3 有序列表 1 2 a. 2.1 b. 2.2 3 有序列表与无序列表混排 1 2 a. 2.1 b. 2.2* 2.2.1 引用只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。 这是引用文本 图片与链接图片 链接Mou 水平线三个「 - 」或「 * 」都可以画出一条水平分割线 使用（—）的水平分割线 使用（***）的水平分割线 代码框两对「 123456代码前加四个空格键 代码前加一个 tab 键### 两对‘ ``` ’包裹```print(&apos;Hello Word!&apos;); 四个空格print(&apos;Hello Word!&apos;); 一个 tab 键print(&apos;Hello Word!&apos;); 脚注脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。 点击右上方的小数字有注解$[^1]$ $[^1] :$这里是注解这是随机文本这是随机文本这是随机文本 注释注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。 首行缩进关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？在输入法的「全角」模式下，输入两个空格键即可。 引号在网页上写文章建议使用直角引号『「」』。 利用Markdown创建表格Markdown作为一种轻量级书写/写作语言，并没有提供很好的排版、编辑等功能。因此，如果想要利用Markdown创建表格（特别是复杂表格），其实是一项不太轻松的事情。经过笔者在简书平台上的测试与其他若干帖子的表述，Markdown应是只提供了最简单的创建表格与内容对齐方式的功能。总结而言，有如下两种最为直观的创建表格方式: 简单方式Name | Academy | score - | :-: | -: Harry Potter | Gryffindor| 90 Hermione Granger | Gryffindor | 100 Draco Malfoy | Slytherin | 90 Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 原生方式| Name | Academy | score | | - | :-: | -: | | Harry Potter | Gryffindor| 90 | | Hermione Granger | Gryffindor | 100 | | Draco Malfoy | Slytherin | 90 | Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 语法说明： 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； 列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。 这样傻瓜的表格创建方式十分符合Markdown简小精悍的语言气质，具有上手快、即学即用的优势。但傻瓜的定义方式显然不能满足很多处女座的要求，比如文章——“Linux备忘录-Linux中文件/文件夹按照时间顺序升序/降序排列”的表格如下： | 参数 |详细解释|备注| | - | :-: | -: | | -l | use a long listing format |以长列表方式显示（显示出文件/文件夹详细信息） | | -t | sort by modification time |按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） | |-r | reverse order while sorting |逆序排列| 参数 详细解释 备注 -l use a long listing format 以长列表方式显示（显示出文件/文件夹详细信息） -t sort by modification time 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） -r reverse order while sorting 逆序排列 单元格排列不齐整、第一列太窄而第三列略宽，如此不堪的视觉效果着实让强迫症患者们难以忍受。还好，利用HTML可以弥补Markdown这一缺陷，甚至可以在创建表格时其他诸多表现方面锦上添花。 Markdown 添加 MathJax 数学公式添加公式的方法行内公式 $行内公式$ 行间公式 $$行间公式$$ MathJax 数学公式语法呈现位置注意: 在公式的前一行和后一行，要注意空一行，否则公式会出错。 所有公式定义格式为 \$…$ 具体语句例如 \$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 显示为： $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 居中并放大显示 \$\$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 显示为： $$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 希腊字母 显示 命令 显示 命令 α \$\alpha\$ β \$\beta\$ γ \$\gamma\$ δ \$\delta\$ ϵ \$\epsilon\$ ζ \$\zeta\$ η \$\eta\$ θ \$\theta\$ ι \$\iota\$ κ \$\kappa\$ λ \$\lambda\$ μ \$\mu\$ ν \$\nu\$ ξ \$\xi\$ π \$\pi\$ ρ \$\rho\$ σ \$\sigma\$ τ \$\tau\$ υ \$\upsilon\$ ϕ \$\phi\$ χ \$\chi\$ ψ \$\psi\$ ω \$\omega\$ 如果需要大写的希腊字母，只需将命令的首字母大写即可(有的字母没有大写)，如 \$\gamma$ &amp; \$\Gamma$ $\gamma$ &amp; $\Gamma$ 若需要斜体希腊字母，在命令前加上var前缀即可(大写可斜)，如 \$\Gamma$ &amp; \$\varGamma$ $\Gamma$ &amp; $\varGamma$ 字母修饰上下标 上标：^ 下标：_ \$C_n^2$ $$C_n^2$$ 矢量 例1 \$\vec a$ $\vec a$ 例2 \$\overrightarrow a$ $\overrightarrow xy$ 字体 - Typewriter\$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ 分组 - {}有分组功能，如\$10^{10}\$ \&amp; \$10^10\$$10^{10}$ &amp; $10^10$ 括号 小括号：\$()$呈现为 $()$ 中括号：\$[]$呈现为 $[]$ 尖括号：\$\langle\rangle$呈现为 $\langle\rangle$ - 此处为与分组符号{}相区别，使用转义字符\ 使用\left(或\right)使符号大小与邻近的公式相适应；该语句适用于所有括号类型 \$(\frac{x}{y})$呈现为 $(\frac{x}{y})$ 而\$\left(\frac{x}{y}\right)$呈现为 $\left(\frac{x}{y}\right)$ 注意: 在公式的前后，必须留有一个空格或者换行，否则无法识别。 求和、极限与积分求和：\sum 举例：\$\sum_{i=1}^n{a_i}$ $\sum_{i=1}^n{a_i}$ 极限：\$\lim_{x\to 0}$ $\lim_{x\to 0}$ 积分：\$\int$ $\int$ 举例：\$\int_0^\infty{fxdx}$ $\int_0^\infty{fxdx}$ \$\iint$ $\iint$ \$\iiint$ $\iiint$ 连乘：\$\prod$ $\prod$ 分式与根式分式(fractions)：\$\frac{公式1}{公式2}$ $\frac{公式1}{公式2}$ 根式：\$\sqrt[x]{y}$ $\sqrt[x]{y}$ 特殊符号 显示 命令 ∞ \$\infty$ ∪ \$\cup$ ∩ \$\cap$ ⊂ \$\subset$ ⊆ \$\subseteq$ ⊃ \$\supset$ ∈ \$\in$ ∉ \$\notin$ ∅ \$\varnothing$ ∀ \$\forall$ ∃ \$\exists$ ¬ \$\lnot$ ∇ \$\nabla$ ∂ \$\partial$ 空格 LaTeX语法本身会忽略空格的存在 小空格：\$a\ b$呈现为 $a\ b$ 4格空格：\$a\quad b$呈现为 $a\quad b$ 矩阵边框在起始、结束标记处用下列词替换matrix pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 省略元素横省略号：\cdots竖省略号：\vdots斜省略号：\ddots举例 $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\\ \end{bmatrix}$$ $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\ \end{bmatrix}$$ 阵列需要array环境：起始、结束处以{array}声明 对齐方式：在{array}后以{}逐行统一声明 左对齐：l；居中：c；右对齐：r 竖直线：在声明对齐方式时，插入|建立竖直线 插入水平线：\hline 方程组需要cases环境：起始、结束处以{cases}声明举例 $$\begin{cases} a_1x+b_1y+c_1z=d_1\\\ a_2x+b_2y+c_2z=d_2\\\ a_3x+b_3y+c_3z=d_3\\\ \end{cases}$$ $$\begin{cases} a_1x+b_1y+c_1z=d_1\\ a_2x+b_2y+c_2z=d_2\\ a_3x+b_3y+c_3z=d_3\\ \end{cases}$$]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个博客！]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%81%2F</url>
    <content type="text"><![CDATA[第一个博客从这个博客开始，新的学习阶段开启了！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>NoteBook</tag>
      </tags>
  </entry>
</search>
