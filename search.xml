<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[点滴积累]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%82%B9%E6%BB%B4%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[hexo生成博文插入图片 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ! [你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>日常记录</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——EM算法]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[EM算法EM简介EM(Expectation Mmaximization) 是一种迭代算法， 用于含隐变量(Latent Variable) 的概率模型参数的极大似然估计， 或极大后验概率估计 EM算法由两步组成， 求期望的E步，和求极大的M步。EM算法可以看成是特殊情况下计算极大似然的一种算法。现实的数据经常有一些比较奇怪的问题，比如缺失数据、含有隐变量等问题。当这些问题出现的时候，计算极大似然函数通常是比较困难的，而EM算法可以解决这个问题。 EM算法已经有很多应用，比如最经典的Hidden Markov模型等。经济学中，除了逐渐开始受到重视的HMM模型（例如Yin and Zhao, 2015），其他领域也有可能涉及到EM算法，比如在Train的《Discrete Choice Methods with Simulation》就给出了一个 $mixed logit$ 模型的EM算法。 EM算法的预备知识 极大似然估计 1 举例说明：经典问题——学生身高问题 我们需要调查我们学校的男生和女生的身高分布。 假设你在校园里随便找了100个男生和100个女生。他们共200个人。将他们按照性别划分为两组，然后先统计抽样得到的100个男生的身高。假设他们的身高是服从高斯分布的。但是这个分布的均值u和方差∂2我们不知道，这两个参数就是我们要估计的。记作θ=[u, ∂]T。问题：我们知道样本所服从的概率分布的模型和一些样本，而不知道该模型中的参数。我们已知的有两个：（1）样本服从的分布模型（2）随机抽取的样本 需要通过极大似然估计求出的包括：模型的参数总的来说：极大似然估计就是用来估计模型参数的统计学方法。 2 如何估计 问题数学化： (1)样本集: x={$x_1,x_2,…,x_N$}, $N=100$。 (2)概率密度：$p(x_i|\theta)$ 抽到男生$i$（的身高）的概率 100个样本之间独立同分布，所以我同时抽到这100个男生的概率就是他们各自概率的乘积。就是从分布是$p(x|\theta)$ 的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$这个概率反映了，在概率密度函数的参数是$\theta$时，得到X这组样本的概率。 需要找到一个参数θ，其对应的似然函数$L(\theta)$最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做$\theta$的最大似然估计量，记为$$argmaxL(\theta)$$ 3 求最大似然函数估计值的一般步骤 首先，写出似然函数：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$其次，对似然函数取对数，并整理：$$H(\theta)=lnL(\theta)=ln\prod_{i=1}^n{p(x_i|\theta)}=\sum_{i=1}^n{lnp(x_i|\theta)}$$然后，求导数，令导数为0，得到似然方程；最后，解似然方程，得到的参数即为所求。 4 总结 多数情况下我们是根据已知条件来推算结果，而极大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS环境搭建]]></title>
    <url>%2F2018%2F06%2F05%2FCentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[系统安装电脑配置 微星1080Ti 至强E5 -2620v4 技嘉的主板 踩坑记录将CentOS 7.4镜像刻到U盘之后，向服务器安装时，使用U盘启动会出现两种启动选项，一种是UEFI启动选项，一种是默认的启动选项，如果不使用UEFI方式安装，那么一般是没有问题的，如果选择UEFI方式安装系统，那么引导系统时会出现如下的提示： [sdb] No Caching mode page found [sdb] Assuming drive cache:write through Could not boot /dev/root does not exist 然后命令行就卡在这了，现在只需要耐心等待，等一会之后会不断的滚动错误警告，这个时候继续等待，那么一会就会出来命令行输入界面，这个时候输入以下命令： ls /dev/sd* 输入命令之后会列出所有的存储设备，这个时候一般情况下第一块硬盘是sda，如果有多个分区，那么依次就是sda1、sda2等等，如果有两块硬盘那么就是sdb，U盘一般是排最后的号，如果有一块硬盘，那么U盘就是sdb，如果有两块硬盘，那么U盘就是sdc，U盘一般会有sdc和sdc4两个选项，sdc属于U盘存储，sdc4就是镜像所在分区了，这样一般是没有问题的，如果出现问题，那么接下来多配置几次就好了，接下来输入命令reboot重启计算机，在安装界面，先不要选择安装，这个时候按一下e键，会进入编辑界面，移动光标进行如下修改： 在第二行默认是：vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 把这行修改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4:/ quiet 就是把hd:和quiet之间的内容修改为U盘镜像所在位置这样就可以了，注意要写成/dev/sdc4:/ 然后根据提示按Ctrl+X键就可以开始安装了，现在就正常进入安装界面了 NVIDIA驱动安装1、在官网上http://www.geforce.cn/drivers搜索到对应型号的显卡驱动并下载，下载到的驱动文件是一个后缀名为.run的文件（例如NVIDIA-Linux-x86_64-384.98.run）； 2、安装gcc编译环境以及内核相关的包： yum install kernel-devel kernel-doc kernel-headers gcc* glibc* glibc-*注意：安装内核包时需要先检查一下当前内核版本是否与所要安装的kernel-devel/kernel-doc/kernel-headers的版本一致，请务必保持两者版本一致，否则后续的编译过程会出问题。 3、禁用系统默认安装的 nouveau 驱动，修改/etc/modprobe.d/blacklist.conf 文件： 修改配置echo -e &quot;blacklist nouveau\noptions nouveau modeset=0&quot; &gt; /etc/modprobe.d/blacklist.conf 备份原来的镜像文件mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak 重建新镜像文件dracut /boot/initramfs-$(uname -r).img $(uname -r) 重启reboot 在命令行界面init 5 查看nouveau是否启动，如果结果为空即为禁用成功lsmod | grep nouveau 4、安装DKMS模块 DKMS全称是DynamicKernel ModuleSupport，它可以帮我们维护内核外的驱动程序，在内核版本变动之后可以自动重新生成新的模块。 sudo yum install DKMS 5、执行显卡驱动安装脚本（如果内核版本一致，就不需要指定–kernel-source-path和-k） ./NVIDIA-Linux-x86_64-384.98.run --kernel-source-path=/usr/src/kernels/3.10.0-693.11.1.el7.x86_64/ -k $(uname -r) --dkms -s 6、若步骤5执行过程中没报错，则安装成功。重启，执行nvidia-smi可查看相关信息。如若出现重启系统驱动找不到的情况，在装完驱动后，切记，先不要重启，使用 init5 和 init 3 交替切换，几次后，会进入图形界面（其中init 5为进入图形界面的命令），之后，在图形界面，重新编译一下启动项。 CUDA&amp;&amp;CUDNN 关于cuda和cudnn的安装，这一点尤其要注意。我在CentOS7.5(更新后的版本，初始装的时候为7.4)上安装CUDA9.2时，无法与NVIDIA的驱动匹配，因此退而求其次，选择了CUDA9.1，同时CUDNN选择7.0.5版本。注意 不要下载cudnn-9.1-linux-ppc64le-v7.1.tgz，因为ppc64le并不是针对X64的电脑系统CUDA的安装我选择了使用yum安装的方式，因为之前使用命令行，出现了未知的错误，导致系统重装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[照片]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/AbHkeLsjjTcKFxnfDK5sftCVtW4EGFV4CYdnA8fRl1pUxIRiR7ntMUdz3+oa/drknFUOG23ueFUDhP27elVt++Xo3q4ts/LLbCygi8W/N88qxlW+NdU0CVJIsfBpwBFj6aMvkYYBQKWhTziliG0OjGDLj7n8tTxdm2JWBlzO1He03JL4/jUlNqogufFYSum9Fcc9FpvNtusHQmXKeaRTOQul7Dcr+YiyKnNQ+aV0c1rDPDAdEliIW var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>照片</category>
      </categories>
      <tags>
        <tag>白痴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的网站逻辑]]></title>
    <url>%2F2018%2F05%2F29%2FDjango%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Django实战——后台逻辑Django用户 （登录 注册 找回密码）登录 后台的操作放在对应app的views文件下，当我们在路由中添加一个url，django会自动为我们生成一个request，并添加到函数里面。首先判断请求方法，是POST还是GET。然后跳转到对应的页面进行操作。 对登录账户进行验证（采用类来做） 得到用户名和密码后，使用django.contrib.auth.authenticate进行验证，验证成功的话得到一个对象，然后进行对应后台逻辑的编写，即调用django.contrib.auth.login进行验证。 对登录成功后返回index.html文件的状态处理，需要在html文件中进行判断，用户是否登录，调用request.user.user.is_authenticated来进行判断。决定显示哪一行代码。 自定义认证方法，实现邮箱的登录方式（重定义方式） Seesion和Cookie机制 无状态请求 有状态请求 注册 准备工具 添加插件（captcha） 提交注册信息（包括注册码）发送邮件验证注册信息激活账户 找回密码 采用类似于激活账户的方式来实现]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adm-zip工具]]></title>
    <url>%2F2018%2F05%2F29%2FAdm-zip%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Adm-zip介绍 Adm-zip是JavaScript中的一款与压缩文件相关的插件，其功能相当的强大（我看来），我用其实现了对Word文档的内容替换。 Word 文档本质上是一个压缩 文件夹，其中的word文件夹下的document.xml文件是包含文档内容的文件，而我们需要操作的也正是这个文件。 Adm-zip这款插件则正好满足我们即对压缩文件内部条目文件的处理，同时又保证不影响压缩文件内部其余文件的要求。 我们需要的函数接口主要有四个，分别为： 读取压缩文件内指定目录里面的文件或者文件夹： Admzip.readAsText() 删除压缩文件内的指定文件或者文件夹： Admzip.deleteFile() 将指定文件写入到压缩文件夹中： Admzip.addFile() 将所做的更改重新写入文件（可以是当前文件，也可以重命名的word文档） Admzip.writeZip() 关于Adm-zip的使用方法，暂时只发现了这样一种，其还有别的Api接口，有兴趣的小伙伴可以自己再研究下^_^]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Adm-zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MARKDOWN语法熟悉]]></title>
    <url>%2F2018%2F05%2F28%2FMARKDOWN%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[基础标题测试一级标题二级标题三级标题四级标题五级标题六级标题换行和分段未换行未换行测试示例 换行后已换行测试（后有两个空格）示例 分段分段测试 分段 文本样式加粗(使用两个*号)斜体（使用一个号）*删除线(使用两个波浪线)‘底纹（单引号）’ 列表在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。 无序列表： 在文本前加 「 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）在 「 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。 无序列表 1 2 2.1 2.1.1 2.1.1.1 3 有序列表 1 2 a. 2.1 b. 2.2 3 有序列表与无序列表混排 1 2 a. 2.1 b. 2.2* 2.2.1 引用只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。 这是引用文本 图片与链接图片 链接Mou 水平线三个「 - 」或「 * 」都可以画出一条水平分割线 使用（—）的水平分割线 使用（***）的水平分割线 代码框两对「 123456代码前加四个空格键 代码前加一个 tab 键### 两对‘ ``` ’包裹```print(&apos;Hello Word!&apos;); 四个空格print(&apos;Hello Word!&apos;); 一个 tab 键print(&apos;Hello Word!&apos;); 脚注脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。 点击右上方的小数字有注解 $[^1]$ $[^1]$ :这里是注解这是随机文本这是随机文本这是随机文本 注释注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。 首行缩进关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？在输入法的「全角」模式下，输入两个空格键即可。 引号在网页上写文章建议使用直角引号『「」』。 利用Markdown创建表格Markdown作为一种轻量级书写/写作语言，并没有提供很好的排版、编辑等功能。因此，如果想要利用Markdown创建表格（特别是复杂表格），其实是一项不太轻松的事情。经过笔者在简书平台上的测试与其他若干帖子的表述，Markdown应是只提供了最简单的创建表格与内容对齐方式的功能。总结而言，有如下两种最为直观的创建表格方式: 简单方式Name | Academy | score - | :-: | -: Harry Potter | Gryffindor| 90 Hermione Granger | Gryffindor | 100 Draco Malfoy | Slytherin | 90 Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 原生方式| Name | Academy | score | | - | :-: | -: | | Harry Potter | Gryffindor| 90 | | Hermione Granger | Gryffindor | 100 | | Draco Malfoy | Slytherin | 90 | Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 语法说明： 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； 列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。 这样傻瓜的表格创建方式十分符合Markdown简小精悍的语言气质，具有上手快、即学即用的优势。但傻瓜的定义方式显然不能满足很多处女座的要求，比如文章——“Linux备忘录-Linux中文件/文件夹按照时间顺序升序/降序排列”的表格如下： | 参数 |详细解释|备注| | - | :-: | -: | | -l | use a long listing format |以长列表方式显示（显示出文件/文件夹详细信息） | | -t | sort by modification time |按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） | |-r | reverse order while sorting |逆序排列| 参数 详细解释 备注 -l use a long listing format 以长列表方式显示（显示出文件/文件夹详细信息） -t sort by modification time 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） -r reverse order while sorting 逆序排列 单元格排列不齐整、第一列太窄而第三列略宽，如此不堪的视觉效果着实让强迫症患者们难以忍受。还好，利用HTML可以弥补Markdown这一缺陷，甚至可以在创建表格时其他诸多表现方面锦上添花。 Markdown 添加 MathJax 数学公式添加公式的方法行内公式 $行内公式$ 行间公式 $$行间公式$$ MathJax 数学公式语法呈现位置注意: 在公式的前一行和后一行，要注意空一行，否则公式会出错。 所有公式定义格式为 \$…$ 具体语句例如 \$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 显示为： $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 居中并放大显示 \$\$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 显示为： $$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 希腊字母 显示 命令 显示 命令 α \$\alpha\$ β \$\beta\$ γ \$\gamma\$ δ \$\delta\$ ϵ \$\epsilon\$ ζ \$\zeta\$ η \$\eta\$ θ \$\theta\$ ι \$\iota\$ κ \$\kappa\$ λ \$\lambda\$ μ \$\mu\$ ν \$\nu\$ ξ \$\xi\$ π \$\pi\$ ρ \$\rho\$ σ \$\sigma\$ τ \$\tau\$ υ \$\upsilon\$ ϕ \$\phi\$ χ \$\chi\$ ψ \$\psi\$ ω \$\omega\$ 如果需要大写的希腊字母，只需将命令的首字母大写即可(有的字母没有大写)，如 \$\gamma$ &amp; \$\Gamma$ $\gamma$ &amp; $\Gamma$ 若需要斜体希腊字母，在命令前加上var前缀即可(大写可斜)，如 \$\Gamma$ &amp; \$\varGamma$ $\Gamma$ &amp; $\varGamma$ 字母修饰上下标 上标：^ 下标：_ \$C_n^2$ $$C_n^2$$ 矢量 例1 \$\vec a$ $\vec a$ 例2 \$\overrightarrow a$ $\overrightarrow xy$ 字体 - Typewriter\$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ 分组 - {}有分组功能，如\$10^{10}\$ \&amp; \$10^10\$$10^{10}$ &amp; $10^10$ 括号 小括号：\$()$呈现为 $()$ 中括号：\$[]$呈现为 $[]$ 尖括号：\$\langle\rangle$呈现为 $\langle\rangle$ - 此处为与分组符号{}相区别，使用转义字符\ 使用\left(或\right)使符号大小与邻近的公式相适应；该语句适用于所有括号类型 \$(\frac{x}{y})$呈现为 $(\frac{x}{y})$ 而\$\left(\frac{x}{y}\right)$呈现为 $\left(\frac{x}{y}\right)$ 注意: 在公式的前后，必须留有一个空格或者换行，否则无法识别。 求和、极限与积分求和：\sum 举例：\$\sum_{i=1}^n{a_i}$ $\sum_{i=1}^n{a_i}$ 极限：\$\lim_{x\to 0}$ $\lim_{x\to 0}$ 积分：\$\int$ $\int$ 举例：\$\int_0^\infty{fxdx}$ $\int_0^\infty{fxdx}$ \$\iint$ $\iint$ \$\iiint$ $\iiint$ 连乘：\$\prod$ $\prod$ 分式与根式分式(fractions)：\$\frac{公式1}{公式2}$ $\frac{公式1}{公式2}$ 根式：\$\sqrt[x]{y}$ $\sqrt[x]{y}$ 特殊符号 显示 命令 ∞ \$\infty$ ∪ \$\cup$ ∩ \$\cap$ ⊂ \$\subset$ ⊆ \$\subseteq$ ⊃ \$\supset$ ∈ \$\in$ ∉ \$\notin$ ∅ \$\varnothing$ ∀ \$\forall$ ∃ \$\exists$ ¬ \$\lnot$ ∇ \$\nabla$ ∂ \$\partial$ 空格 LaTeX语法本身会忽略空格的存在 小空格：\$a\ b$呈现为 $a\ b$ 4格空格：\$a\quad b$呈现为 $a\quad b$ 矩阵边框在起始、结束标记处用下列词替换matrix pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 省略元素横省略号：\cdots竖省略号：\vdots斜省略号：\ddots举例 $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\\ \end{bmatrix}$$ $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\ \end{bmatrix}$$ 阵列需要array环境：起始、结束处以{array}声明 对齐方式：在{array}后以{}逐行统一声明 左对齐：l；居中：c；右对齐：r 竖直线：在声明对齐方式时，插入|建立竖直线 插入水平线：\hline 方程组需要cases环境：起始、结束处以{cases}声明举例 $$\begin{cases} a_1x+b_1y+c_1z=d_1\\\ a_2x+b_2y+c_2z=d_2\\\ a_3x+b_3y+c_3z=d_3\\\ \end{cases}$$ $$\begin{cases} a_1x+b_1y+c_1z=d_1\\ a_2x+b_2y+c_2z=d_2\\ a_3x+b_3y+c_3z=d_3\\ \end{cases}$$]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个博客！]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%81%2F</url>
    <content type="text"><![CDATA[第一个博客从这个博客开始，新的学习阶段开启了！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>NoteBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
