<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7为firewalld添加开放端口及相关操作]]></title>
    <url>%2F2018%2F07%2F05%2FCentOS7%E4%B8%BAfirewalld%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[firewalld的基本使用启动： systemctl start firewalld 查看状态： systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctlstop firewalld.service 重启一个服务：systemctlrestart firewalld.service 显示一个服务的状态：systemctlstatus firewalld.service 在开机时启用一个服务：systemctlenable firewalld.service 在开机时禁用一个服务：systemctldisable firewalld.service 查看服务是否开机启动：systemctlis-enabled firewalld.service 查看已启动的服务列表：systemctllist-unit-files|grep enabled 查看启动失败的服务列表：systemctl--failed 配置firewalld-cmd查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd--zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd--get-active-zones 查看指定接口所属区域： firewall-cmd--get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入firewall-cmd --reload 查看firewall-cmd --zone=public --query-port=80/tcp 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看firewall是否运行,下面两个命令都可以systemctl status firewalld.service firewall-cmd --state 查看当前开了哪些端口其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。 firewall-cmd --list-services 查看还有哪些服务可以打开firewall-cmd --get-services 查看所有打开的端口：firewall-cmd --zone=public --list-ports 更新防火墙规则：firewall-cmd --reload]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs与Django图片信息传输]]></title>
    <url>%2F2018%2F07%2F05%2FNodejs%E4%B8%8EDjango%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Django文档——Model字段类型]]></title>
    <url>%2F2018%2F06%2F14%2FDjango%E6%96%87%E6%A1%A3%E2%80%94%E2%80%94Model%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字段类型(Field types)AutoField它是一个根据 ID 自增长的 IntegerField 字段。通常，你不必直接使用该字段。如果你没在别的字段上指定主 键，Django 就会自动添加主键字段。 BigIntegerField64位整数，类似于IntegerField，范围从-9223372036854775808 到9223372036854775807。默认的form widget 是TextInput。 BooleanField一个布尔值(true/false)字段。 默认的form widget是CheckboxInput。 如果要使用null作为空值，可使用NullBooleanField。 CharFieldclass CharField(max_length=None[, **options]) 它是一个字符串字段，对小字符串和大字符串都适用。 对于更大的文本，应该使用TextField 。 默认的form widget是TextInput。 CharField 有一个必须传入的参数：max_length,字段的最大字符数。它作用于数据库层级和 Django 的数据验证层级。 CommaSeparatedInterFieldclass CommaSeparatedIntegerField(max_length=None[, **options]) 它用来存放以逗号间隔的整数序列。和 CharField 一样，必须为它提供 max_length 参数。而且要注意不同数据库对 max_length 的限制。 DateFieldclass DateField([auto_now=False, auto_now_add=False, **options]) 该字段利用 Python 的 datetime.date 实例来表示日期。下面是它额外的可选参数： DateField.auto_now：每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示 “最后修改” 时间。要注意使用的是当前日期，而并非默认值，所以 不能通过重写默认值的办法来改变保存时间。 DateField.auto_now_add：在第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。它使用的同样是当前日期，而非默认值。 默认的form widget是TextInput。 Note:当auto_now或者auto_now_add设置为True时，字段会有editable=True和blank=True的设定。 DateTimeFieldclass DateTimeField([auto_now=False, auto_now_add=False, **options]) 该字段利用 datetime.datetime 实例表示日期和时间。该字段所按受的参数和 DateField 一样。 默认的form widget是TextInput。Django 的admin使用两个带有 JavaScript 快捷选项TextInput分别表示日期和时间。 DecimalFieldclass DecimalField(max_digits=None, decimal_places=None[, **options]) 它是使用 Decimal 实例表示固定精度的十进制数的字段。它有两个必须的参数： DecimalField.max_digits：数字允许的最大位数 DecimalField.decimal_places：小数的最大位数 例如，要存储的数字最大值是999，而带有两个小数位，你可以使用： 1models.DecimalField(…, max_digits=5, decimal_places=2)要存储大约是十亿级且带有10个小数位的数字，就这样写： 1models.DecimalField(…, max_digits=19, decimal_places=10)默认的form widget是TextInput。 EmailFieldclass EmailField([max_length=75, **options]) 它是带有 email 合法性检测的A CharField 。 Note：最大长度默认为75，并不能存储所有与RFC3696/5321兼容的email地址。如果要存储所有，请设置 max_length=254。设置为75是历史遗留问题。 FileFieldclass FileField(upload_to=None[, max_length=100, **options]) 文件上传字段 Note：该字段不支持 primary_key 和 unique 参数，否则会抛出 TypeError 异常。 它有一个必须的参数： FileField.upload_to 用于保存文件的本地文件系统。它根据 MEDIA_ROOT 设置确定该文件的 url 属性。 该路径可以包含 时间格式串strftime()，可以在上传文件的时候替换成当时日期／时间(这样，就不会出现在上传文件把某个目录塞满的情况了)。 该参数也可以是一个可调用项，比如是一个函数，可以调用函数获得包含文件名的上传路径。这个可调用项必须要接受两个参数， 并且返回一个保存文件用的 Unix-Style 的路径(用 / 斜杠)。两个参数分别是： instance ：定义了当前 FileField 的 model 实例。更准确地说，就是以该文件为附件的 model 实例。 大多数情况下，在保存该文件时， model 实例对象还并没有保存到数据库，这是因为它很有可能使用默认的 AutoField，而此时它还没有从数据库中获得主键值。 filename ：上传文件的原始名称。在生成最终路径的时候，有可能会用到它。 还有一个可选的参数： FileField.storage 负责保存和获取文件的对象。 默认的form widget是FileInput。 Note：在 model 中使用 FileField 或 ImageField 要按照以下的步骤： 1.在项目settings文件中，你要定义 MEDIA_ROOT ，将它的值设为用来存放上传文件的目录的完整路径。(基于性能的考虑，Django 没有将文件保存在数据库中). 然后定义 MEDIA_URL ，将它的值设为表示该目录的网址。 要确保 web 服务器所用的帐号拥有对该目录的写权限。 2.在 model 里面添加 FileField 或 ImageField ，并且确认已定义了 upload_to 项，让 Django 知道应该用 MEDIA_ROOT 的哪个子目录来保存文件。 3.存储在数据库当中的仅仅只是文件的路径(而且是相对于 MEDIA_ROOT 的相对路径)。你可能已经想到利用 Django 提供的 url 这个方便的属性。举个例子，如果你的 ImageField 名称是 mug_shot，那么你可以在模板 中使用 1就能得到图片的完整网址。 例如，假设你的 MEDIA_ROOT 被设为 ‘/home/media’，upload_to 被设为 ‘photos/%Y/%m/%d’。 upload_to 中 的 ‘%Y/%m/%d’ 是一个strftime()， ‘%Y’ 是四位的年份，’%m’ 是两位的月份， ‘%d’ 是两位的日子。如果你 在2007年01月15号上传了一个文件，那么这个文件就保存在 /home/media/photos/2007/01/15 目录下。 如果你想得到上传文件的本地文件名称，文件网址，或是文件的大小，你可以使用 name, url 和 size 属性。 Note：在上传文件时，要警惕保存文件的位置和文件的类型，这么做的原因是为了避免安全漏洞。对每一个上传 文件都要验证，这样你才能确保上传的文件是你想要的文件。举个例子，如果你盲目地让别人上传文件，而没有 对上传文件进行验证，如果保存文件的目录处于 web 服务器的根目录下，万一有人上传了一个 CGI 或是 PHP 脚本，然后通过访问脚本网址来运行上传的脚本，那可就太危险了。千万不要让这样的事情发生！ 默认情况下，FileField 实例在数据库中的对应列是 varchar(100) ，和其他字段一样，你可以利用max_length 参数改变字段的最大长度。 FileField and FieldFile class FieldFile 当你访问一个Model的FileField字段时，会得到一个FieldFile的实例作为代理去访问底层文件。实例有几种属性和方法可以用来和文件数据进行互动。 FieldFile.url 通过只读的方式调用底层存储(Storage)类的 url() 方法，来访问该文件的相对URL。 FieldFile.open(mode=’rb’) 类似于python的open()方法。 FieldFile.close() 类似于python的close()方法。 FieldFile.save(name,content,save=True) 这种方法将filename和文件内容传递到该字段然后存储到该模型。该方法需要两个必须的参数：name， 文件的名称， content， 包含文件内容的对象。save 参数是可选的，主 要是控制文件修改后实例是否保存。默认是 True 。需要注意的是，content 参数是 django.core.files.File 的一个实例，不是Python的内置File对象。你可以使 用他从现有的Python文件对象中构建一个文件，如下所示： 1234from django.core.files import File Open an existing file using Python’s built-in open()f = open(‘/tmp/hello.world’)myfile = File(f)或者从字符串中构造： 12from django.core.files.base import ContentFilemyfile = ContentFile(“hello world”)FieldFile.delete(save=True) 删除此实例相关的文件，并清除该字段的所有属性。 Note：当delete()被调用时，如果文件正好是打开的，该方法将关闭文件。 save 参数是可选的，控制文件删除后实例是否保存。默认是 True 。 需要注意的是，当一个模型被删除时，相关文件不被删除。如果想删除这些孤立的文件，需要自己去处理（比如，可以手动运行命令清理，也可以通过cron来定期执行清理命令） FilePathFieldclass FilePathField(path=None[, match=None, recursive=False, max_length=100, **options]) 它是一个 CharField ，它用来选择文件系统下某个目录里面的某些文件。它有三个专有的参数，只有第一个参 数是必须的： FilePathField.path 这个参数是必需的。它是一个目录的绝对路径，而这个目录就是 FilePathField 用来选择文件的那个目录。比 如： “/home/images”. FilePathField.match 可选参数。它是一个正则表达式字符串， FilePathField 用它来过滤文件名称，只有符合条件的文件才出现在 文件选择列表中。要注意正则表达式只匹配文件名，而不是匹配文件路径。例如：”foo.*.txt$” 只匹配名为 foo23.txt 而不匹配 bar.txt 和 foo23.gif。 FilePathField.recursive 可选参数。它的值是 True 或 False。默认值是 False。它指定是否包含 path 下的子目录。 FilePathField.allow_files 该项属于Django1.5新增内容。可选参数，它的值是 True 或 False。默认值是 True。它指定是否包含指定位置的文件。该项与allow_folders 必须有一个是 True。 FilePathField.allow_folders Django1.5新增内容。可选参数，它的值是True或False。默认是False。它指定是否包含指定位置的目录。该项与allow_files必须有一个是 True。 前面已经提到了 match 只匹配文件名称，而不是文件路径。所以下面这个例子： 1FilePathField(path=”/home/images”, match=”foo.*”, recursive=True)将匹配 /home/images/foo.gif ，而不匹配 /home/images/foo/bar.gif。这是因为 match 只匹配文件名(foo.gif 和 bar.gif). 默认情况下， FilePathField 实例在数据库中的对应列是varchar(100) 。和其他字段一样，你可以利用 max_length 参数改变字段的最大长度。 FloatFieldclass FloatField([**options]) 该字段在 Python 中使用float 实例来表示一个浮点数。 默认的form widget是TextInput。 请注意FloatField与DecimalField的区别。 ImageFieldclass ImageField(upload_to=None[, height_field=None, width_field=None, max_length=100,**options]) 和 FileField 一样，只是会验证上传对象是不是一个合法的图象文件。 除了那些在 FileField 中有效的参数之外， ImageField 还可以使用 File.height and File.width 两个属性 。 它有两个可选参数： ImageField.height_field 保存图片高度的字段名称。在保存对象时，会根据该字段设定的高度，对图片文件进行缩放转换。 ImageField.width_field 保存图片宽度的字段名称。在保存对象时，会根据该字段设定的宽度，对图片文件进行缩放转换。 默认情况下， ImageField 实例对应着数据库中的varchar(100) 列。和其他字段一样，你可以使 用 max_length 参数来改变字段的最大长度。 IntegerFieldclass IntegerField([**options]) 整数字段。默认的form widget是TextInput。 IPAddressFieldclass IPAddressField([**options]) 以字符串形式(比如 “192.0.2.30”)表示 IP 地址字段。默认的form widget是TextInput。 GenericIPAddressFieldclass GenericIPAddressField([**options]) Django1.4新增。 以字符串形式(比如 “192.0.2.30”或者”2a02:42fe::4”)表示 IP4或者IP6 地址字段。默认的form widget是TextInput。 IPv6的地址格式遵循RFC 4291 section 2.2。比如如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示，例如 “::ffff:192.0.2.0”。 2001:0::0:01可以写成2001::1,而::ffff:0a0a:0a0a可以写成::ffff:10.10.10.10。字母都为小写。 GenericIPAddressField.protocol 验证输入协议的有效性。默认值是 ‘both’ 也就是IPv4或者IPv6。该项不区分大小写。 GenericIPAddressField.unpack_ipv4 解释IPv4映射的地址，像 ::ffff:192.0.2.1 。如果启用该选项，该地址将必解释为 192.0.2.1 。默认是禁止的。只有当 protocol 被设置为 ‘both’ 时才可以启用。 NullBooleanFieldclass NullBooleanField([**options]) 与 BooleanField 相似，但多了一个 NULL 选项。建议用该字段代替使用 null=True 选项的 BooleanField 。 默认的form widget是NullBooleanSelect。 PositiveIntegerFieldclass PositiveIntegerField([**options]) 和 IntegerField 相似，但字段值必须是非负数。 PositiveSmallIntegerFieldclass PositiveSmallIntegerField([**options]) 和 PositiveIntegerField 类似，但数值的取值范围较小，受限于数据库设置。 SlugFieldclass SlugField([max_length=50, **options]) Slug 是一个新闻术语，是指某个事件的短标签。它只能由字母，数字，下划线或连字符组成。通赏情况下，它被用做网址的一部分。 和 CharField 类似，你可以指定 max_length (要注意数据库兼容性和本节提到的 max_length )。如果没有指定 max_length ，Django 会默认字段长度为50。 该字段会自动设置 Field.db_index to True。 基于其他字段的值来自动填充 Slug 字段是很有用的。你可以在 Django 的管理后台中使用prepopulated_fields 来做到这一点。 SmallIntegerFieldclass SmallIntegerField([**options]) 和 IntegerField 类似，但数值的取值范围较小，受限于数据库的限制。 TextFieldclass TextField([**options]) 大文本字段。默认的form widget是Textarea。 TimeFieldclass TimeField([auto_now=False, auto_now_add=False, **options]) 该字段使用 Python 的 datetime.time 实例来表示时间。它和 DateField 接受同样的自动填充的参数。 默认的form widget是TextInput。 URLFieldclass URLField([max_length=200, **options]) 保存 URL 的 CharField 。 和所有 CharField 子类一样，URLField 接受可选的 max_length 参数，该参数默认值是200。]]></content>
  </entry>
  <entry>
    <title><![CDATA[点滴积累]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%82%B9%E6%BB%B4%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[hexo生成博文插入图片 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ! [你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 Error: That port is already in use.的错误。即端口号已经被占用,说明servr已经在运行了(也有可能在后台运行) 那么找到该进程,kill掉即可. 或者最简单的解决方法就是： 在终端输入 sudo fuser -k 8000/tcp 这样和端口8000相关的进程就都关了。 centos下实现word转pdflibreoffice –headless –invisible –convert-to pdf 模版123.docx –outdir /filepath]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>日常记录</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习——EM算法]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[EM算法EM简介EM(Expectation Mmaximization) 是一种迭代算法， 用于含隐变量(Latent Variable) 的概率模型参数的极大似然估计， 或极大后验概率估计 EM算法由两步组成， 求期望的E步，和求极大的M步。EM算法可以看成是特殊情况下计算极大似然的一种算法。现实的数据经常有一些比较奇怪的问题，比如缺失数据、含有隐变量等问题。当这些问题出现的时候，计算极大似然函数通常是比较困难的，而EM算法可以解决这个问题。 EM算法已经有很多应用，比如最经典的Hidden Markov模型等。经济学中，除了逐渐开始受到重视的HMM模型（例如Yin and Zhao, 2015），其他领域也有可能涉及到EM算法，比如在Train的《Discrete Choice Methods with Simulation》就给出了一个 $mixed logit$ 模型的EM算法。 EM算法的预备知识 极大似然估计 1 举例说明：经典问题——学生身高问题 我们需要调查我们学校的男生和女生的身高分布。 假设你在校园里随便找了100个男生和100个女生。他们共200个人。将他们按照性别划分为两组，然后先统计抽样得到的100个男生的身高。假设他们的身高是服从高斯分布的。但是这个分布的均值u和方差∂2我们不知道，这两个参数就是我们要估计的。记作θ=[u, ∂]T。问题：我们知道样本所服从的概率分布的模型和一些样本，而不知道该模型中的参数。我们已知的有两个：（1）样本服从的分布模型（2）随机抽取的样本 需要通过极大似然估计求出的包括：模型的参数总的来说：极大似然估计就是用来估计模型参数的统计学方法。 2 如何估计 问题数学化： (1)样本集: x={$x_1,x_2,…,x_N$}, $N=100$。 (2)概率密度：$p(x_i|\theta)$ 抽到男生$i$（的身高）的概率 100个样本之间独立同分布，所以我同时抽到这100个男生的概率就是他们各自概率的乘积。就是从分布是$p(x|\theta)$ 的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$这个概率反映了，在概率密度函数的参数是$\theta$时，得到X这组样本的概率。 需要找到一个参数θ，其对应的似然函数$L(\theta)$最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做$\theta$的最大似然估计量，记为$$argmaxL(\theta)$$ 3 求最大似然函数估计值的一般步骤 首先，写出似然函数：$$L(\theta)=L(x_1,…,x_n;\theta)=\prod_{i=1}^n{p(x_i|\theta)},\theta\in\phi$$其次，对似然函数取对数，并整理：$$H(\theta)=lnL(\theta)=ln\prod_{i=1}^n{p(x_i|\theta)}=\sum_{i=1}^n{lnp(x_i|\theta)}$$然后，求导数，令导数为0，得到似然方程；最后，解似然方程，得到的参数即为所求。 4 总结 多数情况下我们是根据已知条件来推算结果，而极大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS环境搭建]]></title>
    <url>%2F2018%2F06%2F05%2FCentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[系统安装电脑配置 微星1080Ti 至强E5 -2620v4 技嘉的主板 踩坑记录将CentOS 7.4镜像刻到U盘之后，向服务器安装时，使用U盘启动会出现两种启动选项，一种是UEFI启动选项，一种是默认的启动选项，如果不使用UEFI方式安装，那么一般是没有问题的，如果选择UEFI方式安装系统，那么引导系统时会出现如下的提示： [sdb] No Caching mode page found [sdb] Assuming drive cache:write through Could not boot /dev/root does not exist 然后命令行就卡在这了，现在只需要耐心等待，等一会之后会不断的滚动错误警告，这个时候继续等待，那么一会就会出来命令行输入界面，这个时候输入以下命令： ls /dev/sd* 输入命令之后会列出所有的存储设备，这个时候一般情况下第一块硬盘是sda，如果有多个分区，那么依次就是sda1、sda2等等，如果有两块硬盘那么就是sdb，U盘一般是排最后的号，如果有一块硬盘，那么U盘就是sdb，如果有两块硬盘，那么U盘就是sdc，U盘一般会有sdc和sdc4两个选项，sdc属于U盘存储，sdc4就是镜像所在分区了，这样一般是没有问题的，如果出现问题，那么接下来多配置几次就好了，接下来输入命令reboot重启计算机，在安装界面，先不要选择安装，这个时候按一下e键，会进入编辑界面，移动光标进行如下修改： 在第二行默认是：vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 把这行修改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4:/ quiet 就是把hd:和quiet之间的内容修改为U盘镜像所在位置这样就可以了，注意要写成/dev/sdc4:/ 然后根据提示按Ctrl+X键就可以开始安装了，现在就正常进入安装界面了 NVIDIA驱动安装1、在官网上http://www.geforce.cn/drivers搜索到对应型号的显卡驱动并下载，下载到的驱动文件是一个后缀名为.run的文件（例如NVIDIA-Linux-x86_64-384.98.run）； 2、安装gcc编译环境以及内核相关的包： yum install kernel-devel kernel-doc kernel-headers gcc* glibc* glibc-*注意：安装内核包时需要先检查一下当前内核版本是否与所要安装的kernel-devel/kernel-doc/kernel-headers的版本一致，请务必保持两者版本一致，否则后续的编译过程会出问题。 3、禁用系统默认安装的 nouveau 驱动，修改/etc/modprobe.d/blacklist.conf 文件： 修改配置echo -e &quot;blacklist nouveau\noptions nouveau modeset=0&quot; &gt; /etc/modprobe.d/blacklist.conf 备份原来的镜像文件mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak 重建新镜像文件dracut /boot/initramfs-$(uname -r).img $(uname -r) 重启reboot 在命令行界面init 5 查看nouveau是否启动，如果结果为空即为禁用成功lsmod | grep nouveau 4、安装DKMS模块 DKMS全称是DynamicKernel ModuleSupport，它可以帮我们维护内核外的驱动程序，在内核版本变动之后可以自动重新生成新的模块。 sudo yum install DKMS 5、执行显卡驱动安装脚本（如果内核版本一致，就不需要指定–kernel-source-path和-k） ./NVIDIA-Linux-x86_64-384.98.run --kernel-source-path=/usr/src/kernels/3.10.0-693.11.1.el7.x86_64/ -k $(uname -r) --dkms -s 6、若步骤5执行过程中没报错，则安装成功。重启，执行nvidia-smi可查看相关信息。如若出现重启系统驱动找不到的情况，在装完驱动后，切记，先不要重启，使用 init5 和 init 3 交替切换，几次后，会进入图形界面（其中init 5为进入图形界面的命令），之后，在图形界面，重新编译一下启动项。 CUDA&amp;&amp;CUDNN 关于cuda和cudnn的安装，这一点尤其要注意。我在CentOS7.5(更新后的版本，初始装的时候为7.4)上安装CUDA9.2时，无法与NVIDIA的驱动匹配，因此退而求其次，选择了CUDA9.1，同时CUDNN选择7.0.5版本。注意 不要下载cudnn-9.1-linux-ppc64le-v7.1.tgz，因为ppc64le并不是针对X64的电脑系统CUDA的安装我选择了使用yum安装的方式，因为之前使用命令行，出现了未知的错误，导致系统重装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[照片]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+vnoOybA9e/J7GRh8iWpJOExVB3LIiP0VEYVaXTiziwuMpVqCBa6sEthzwdhTNNh94noBCIGiV48YsKE70v4wFHhCfM7KYI2oce3ZuUjIkKuZLUixitdCnM4urFtHgSM4tzXmTWj7pQcS+8HBYUWKDYzOhhxZoGYDX0cUXbvRGWby9enJyXluhpkOk2xcHjkOpCh4T50IZ9Xc9G80GAbQrfBGQKh+56BFcvo+aNwY/zRSElv+Jw3nIvqcewcbQiA8X29qA0IVYVEvydnWBr/43MSou79mOUUI= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>照片</category>
      </categories>
      <tags>
        <tag>白痴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的网站逻辑]]></title>
    <url>%2F2018%2F05%2F29%2FDjango%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Django实战——后台逻辑Django用户 （登录 注册 找回密码）登录 后台的操作放在对应app的views文件下，当我们在路由中添加一个url，django会自动为我们生成一个request，并添加到函数里面。首先判断请求方法，是POST还是GET。然后跳转到对应的页面进行操作。 对登录账户进行验证（采用类来做） 得到用户名和密码后，使用django.contrib.auth.authenticate进行验证，验证成功的话得到一个对象，然后进行对应后台逻辑的编写，即调用django.contrib.auth.login进行验证。 对登录成功后返回index.html文件的状态处理，需要在html文件中进行判断，用户是否登录，调用request.user.user.is_authenticated来进行判断。决定显示哪一行代码。 自定义认证方法，实现邮箱的登录方式（重定义方式） Seesion和Cookie机制 无状态请求 有状态请求 注册 准备工具 添加插件（captcha） 提交注册信息（包括注册码）发送邮件验证注册信息激活账户 找回密码 采用类似于激活账户的方式来实现]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adm-zip工具]]></title>
    <url>%2F2018%2F05%2F29%2FAdm-zip%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Adm-zip介绍 Adm-zip是JavaScript中的一款与压缩文件相关的插件，其功能相当的强大（我看来），我用其实现了对Word文档的内容替换。 Word 文档本质上是一个压缩 文件夹，其中的word文件夹下的document.xml文件是包含文档内容的文件，而我们需要操作的也正是这个文件。 Adm-zip这款插件则正好满足我们即对压缩文件内部条目文件的处理，同时又保证不影响压缩文件内部其余文件的要求。 我们需要的函数接口主要有四个，分别为： 读取压缩文件内指定目录里面的文件或者文件夹： Admzip.readAsText() 删除压缩文件内的指定文件或者文件夹： Admzip.deleteFile() 将指定文件写入到压缩文件夹中： Admzip.addFile() 将所做的更改重新写入文件（可以是当前文件，也可以重命名的word文档） Admzip.writeZip() 关于Adm-zip的使用方法，暂时只发现了这样一种，其还有别的Api接口，有兴趣的小伙伴可以自己再研究下^_^]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Adm-zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MARKDOWN语法熟悉]]></title>
    <url>%2F2018%2F05%2F28%2FMARKDOWN%E8%AF%AD%E6%B3%95%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[基础标题测试一级标题二级标题三级标题四级标题五级标题六级标题换行和分段未换行未换行测试示例 换行后已换行测试（后有两个空格）示例 分段分段测试 分段 文本样式加粗(使用两个*号)斜体（使用一个号）*删除线(使用两个波浪线)‘底纹（单引号）’ 列表在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。 无序列表： 在文本前加 「 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）在 「 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。 无序列表 1 2 2.1 2.1.1 2.1.1.1 3 有序列表 1 2 a. 2.1 b. 2.2 3 有序列表与无序列表混排 1 2 a. 2.1 b. 2.2* 2.2.1 引用只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。 这是引用文本 图片与链接图片 链接Mou 水平线三个「 - 」或「 * 」都可以画出一条水平分割线 使用（—）的水平分割线 使用（***）的水平分割线 代码框两对「 123456代码前加四个空格键 代码前加一个 tab 键### 两对‘ ``` ’包裹```print(&apos;Hello Word!&apos;); 四个空格print(&apos;Hello Word!&apos;); 一个 tab 键print(&apos;Hello Word!&apos;); 脚注脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。 点击右上方的小数字有注解 $[^1]$ $[^1]$ :这里是注解这是随机文本这是随机文本这是随机文本 注释注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。 首行缩进关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？在输入法的「全角」模式下，输入两个空格键即可。 引号在网页上写文章建议使用直角引号『「」』。 利用Markdown创建表格Markdown作为一种轻量级书写/写作语言，并没有提供很好的排版、编辑等功能。因此，如果想要利用Markdown创建表格（特别是复杂表格），其实是一项不太轻松的事情。经过笔者在简书平台上的测试与其他若干帖子的表述，Markdown应是只提供了最简单的创建表格与内容对齐方式的功能。总结而言，有如下两种最为直观的创建表格方式: 简单方式Name | Academy | score - | :-: | -: Harry Potter | Gryffindor| 90 Hermione Granger | Gryffindor | 100 Draco Malfoy | Slytherin | 90 Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 原生方式| Name | Academy | score | | - | :-: | -: | | Harry Potter | Gryffindor| 90 | | Hermione Granger | Gryffindor | 100 | | Draco Malfoy | Slytherin | 90 | Name Academy score Harry Potter Gryffindor 90 Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 语法说明： 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； 列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。 这样傻瓜的表格创建方式十分符合Markdown简小精悍的语言气质，具有上手快、即学即用的优势。但傻瓜的定义方式显然不能满足很多处女座的要求，比如文章——“Linux备忘录-Linux中文件/文件夹按照时间顺序升序/降序排列”的表格如下： | 参数 |详细解释|备注| | - | :-: | -: | | -l | use a long listing format |以长列表方式显示（显示出文件/文件夹详细信息） | | -t | sort by modification time |按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） | |-r | reverse order while sorting |逆序排列| 参数 详细解释 备注 -l use a long listing format 以长列表方式显示（显示出文件/文件夹详细信息） -t sort by modification time 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） -r reverse order while sorting 逆序排列 单元格排列不齐整、第一列太窄而第三列略宽，如此不堪的视觉效果着实让强迫症患者们难以忍受。还好，利用HTML可以弥补Markdown这一缺陷，甚至可以在创建表格时其他诸多表现方面锦上添花。 Markdown 添加 MathJax 数学公式添加公式的方法行内公式 $行内公式$ 行间公式 $$行间公式$$ MathJax 数学公式语法呈现位置注意: 在公式的前一行和后一行，要注意空一行，否则公式会出错。 所有公式定义格式为 \$…$ 具体语句例如 \$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 显示为： $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$ 居中并放大显示 \$\$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 显示为： $$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ 希腊字母 显示 命令 显示 命令 α \$\alpha\$ β \$\beta\$ γ \$\gamma\$ δ \$\delta\$ ϵ \$\epsilon\$ ζ \$\zeta\$ η \$\eta\$ θ \$\theta\$ ι \$\iota\$ κ \$\kappa\$ λ \$\lambda\$ μ \$\mu\$ ν \$\nu\$ ξ \$\xi\$ π \$\pi\$ ρ \$\rho\$ σ \$\sigma\$ τ \$\tau\$ υ \$\upsilon\$ ϕ \$\phi\$ χ \$\chi\$ ψ \$\psi\$ ω \$\omega\$ 如果需要大写的希腊字母，只需将命令的首字母大写即可(有的字母没有大写)，如 \$\gamma$ &amp; \$\Gamma$ $\gamma$ &amp; $\Gamma$ 若需要斜体希腊字母，在命令前加上var前缀即可(大写可斜)，如 \$\Gamma$ &amp; \$\varGamma$ $\Gamma$ &amp; $\varGamma$ 字母修饰上下标 上标：^ 下标：_ \$C_n^2$ $$C_n^2$$ 矢量 例1 \$\vec a$ $\vec a$ 例2 \$\overrightarrow a$ $\overrightarrow xy$ 字体 - Typewriter\$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ \$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ 分组 - {}有分组功能，如\$10^{10}\$ \&amp; \$10^10\$$10^{10}$ &amp; $10^10$ 括号 小括号：\$()$呈现为 $()$ 中括号：\$[]$呈现为 $[]$ 尖括号：\$\langle\rangle$呈现为 $\langle\rangle$ - 此处为与分组符号{}相区别，使用转义字符\ 使用\left(或\right)使符号大小与邻近的公式相适应；该语句适用于所有括号类型 \$(\frac{x}{y})$呈现为 $(\frac{x}{y})$ 而\$\left(\frac{x}{y}\right)$呈现为 $\left(\frac{x}{y}\right)$ 注意: 在公式的前后，必须留有一个空格或者换行，否则无法识别。 求和、极限与积分求和：\sum 举例：\$\sum_{i=1}^n{a_i}$ $\sum_{i=1}^n{a_i}$ 极限：\$\lim_{x\to 0}$ $\lim_{x\to 0}$ 积分：\$\int$ $\int$ 举例：\$\int_0^\infty{fxdx}$ $\int_0^\infty{fxdx}$ \$\iint$ $\iint$ \$\iiint$ $\iiint$ 连乘：\$\prod$ $\prod$ 分式与根式分式(fractions)：\$\frac{公式1}{公式2}$ $\frac{公式1}{公式2}$ 根式：\$\sqrt[x]{y}$ $\sqrt[x]{y}$ 特殊符号 显示 命令 ∞ \$\infty$ ∪ \$\cup$ ∩ \$\cap$ ⊂ \$\subset$ ⊆ \$\subseteq$ ⊃ \$\supset$ ∈ \$\in$ ∉ \$\notin$ ∅ \$\varnothing$ ∀ \$\forall$ ∃ \$\exists$ ¬ \$\lnot$ ∇ \$\nabla$ ∂ \$\partial$ 空格 LaTeX语法本身会忽略空格的存在 小空格：\$a\ b$呈现为 $a\ b$ 4格空格：\$a\quad b$呈现为 $a\quad b$ 矩阵边框在起始、结束标记处用下列词替换matrix pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 省略元素横省略号：\cdots竖省略号：\vdots斜省略号：\ddots举例 $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\\ \end{bmatrix}$$ $$\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\ {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\ {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\ {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\ \end{bmatrix}$$ 阵列需要array环境：起始、结束处以{array}声明 对齐方式：在{array}后以{}逐行统一声明 左对齐：l；居中：c；右对齐：r 竖直线：在声明对齐方式时，插入|建立竖直线 插入水平线：\hline 方程组需要cases环境：起始、结束处以{cases}声明举例 $$\begin{cases} a_1x+b_1y+c_1z=d_1\\\ a_2x+b_2y+c_2z=d_2\\\ a_3x+b_3y+c_3z=d_3\\\ \end{cases}$$ $$\begin{cases} a_1x+b_1y+c_1z=d_1\\ a_2x+b_2y+c_2z=d_2\\ a_3x+b_3y+c_3z=d_3\\ \end{cases}$$]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个博客！]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%81%2F</url>
    <content type="text"><![CDATA[第一个博客从这个博客开始，新的学习阶段开启了！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>NoteBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
